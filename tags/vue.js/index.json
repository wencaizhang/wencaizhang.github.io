[{"content":"ffff\n","description":"大话西游","id":2,"section":"gallery","tags":null,"title":"大话西游","uri":"https://webjam.cn/gallery/%E5%A4%A7%E8%AF%9D%E8%A5%BF%E6%B8%B8/"},{"content":"安装 nvm 在 Linux 和 MacOS 上，你可以直接使用下面两个命令来安装 nvm：\n1 2 3 4  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash # 或者 wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash   以上任意一条命令都会下载并执行一个脚本文件，这个脚本会克隆 nvm 的源码到 ~/.nvm 目录下，而且尝试将下面代码添加到当前到命令行配置文件中\n1 2  export NVM_DIR=\u0026#34;$([ -z \u0026#34;${XDG_CONFIG_HOME-}\u0026#34; ] \u0026amp;\u0026amp; printf %s \u0026#34;${HOME}/.nvm\u0026#34; || printf %s \u0026#34;${XDG_CONFIG_HOME}/nvm\u0026#34;)\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm   该文件依赖于你当前使用的命令行解释器（可能是 ~/.bash_profile, ~/.zshrc, ~/.profile, 或者 ~/.bashrc），我使用的是 zsh，因此我的配置文件是 ~/.zshrc，添加代码之后，需要重新加载配置文件才能生效：\n1  source ~/.zshrc   提示：如果安装之后使用 nvm 命令，得到了 nvm: command not found 的提示，可以尝试把命令行窗口关闭再重新打开尝试 nvm 命令\n配置加速镜像源 配置环境变量，将 NVM_NODEJS_ORG_MIRROR 指向淘宝镜像源 http://npm.taobao.org/mirrors/node\n1  export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node   常用命令 (1) 列出已安装 node 版本\n这个命令只会列出通过 nvm 安装的 node 版本，如果是自行安装的 node 并不会被列出来。\n1  nvm ls   你可以通过以下命令来列出远程服务器上所有的可用版本：\n1  nvm ls-remote   Windows 的话，就是：\n1  nvm ls available   (2) 安装多版本 node\n安装指定版本 node 的命令格式如下：\n1  nvm install \u0026lt;version\u0026gt;   例如，我们要安装4.2.2版本，可以用如下命令：\n1  nvm install 4.22   另外 nvm 遵守语义化版本命名规则。例如，你想安装最新的 4.2 系列的最新一个版本的话，可以运行：\n1  nvm install 4.2   那么 nvm 会自动寻找 4.2.x 中最高的版本来安装。\n(3) 切换 node 版本\n1  nvm use \u0026lt;version\u0026gt;   .nvmrc 当你使用 nvm 的时候，通常代表着你有\n参考文章  nvm GitHub  ","description":"Create a modern vuepress blog in 5 minutes!","id":3,"section":"posts","tags":["blog","python"],"title":"nvm 安装使用说明","uri":"https://webjam.cn/posts/2020/nvm-tutorial/"},{"content":"在 Vue.js 组件中使用 scoped 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。\n如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 \u0026raquo;\u0026gt; 操作符：\n1 2 3  \u0026lt;style scoped\u0026gt; .a \u0026gt;\u0026gt;\u0026gt; .b { /* ... */ } \u0026lt;/style\u0026gt;   上述代码将会编译成：\n1  .a[data-v-f3f3eg9] .b { /* ... */ }   有些像 Sass 之类的预处理器无法正确解析 \u0026gt;\u0026gt;\u0026gt;。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符取而代之 —— 两者都是 \u0026gt;\u0026gt;\u0026gt; 的别名，同样可以正常工作\n","description":"优雅覆盖 Vue.js 组件内部样式","id":4,"section":"posts","tags":["sass","node-sass","dart-sass"],"title":"优雅覆盖 Vue.js 组件内部样式","uri":"https://webjam.cn/posts/2020/node-sass-to-dart-sass/"},{"content":"Sass 的历史 Sass 最初是用 Ruby 编写的，称为 Ruby Sass。然后是 LibSass，LibSass 用 C/C++ 实现。后来，Sass 官方宣布了 sass 的全新实现：Dart Sass。\nRuby Sass 基于高级编程语言开发，优点是语法简单，扩展性强。但是在长期使用过程中逐渐发现 Ruby Sass 的编译速度太慢了，另外 Ruby Sass 要求用户在电脑上安装 Ruby，这对非 Ruby 用户并不友好。\nLibSass 的优点是简单、快速、易于集成，很容易使用其他编程语言进行它进行封装。目前基于 LibSass 的封装多达十几种编程语言，前端最常见的就是基于 Node 封装的 node-sass 了，除此之外，还有基于 Java、Go、Lua、PHP、Python 等编程语言封装的版本，具体列表可以看这里。\nLibSass 虽然解决了 Ruby Sass 带来的问题，但是 LibSass 也有自己的缺点：底层语言使添加新功能变得相当困难。\nSass 官方最终选择了 Dart 来重写 Sass，Dart 能够保证很好的编译速度，并且 Dart 在大项目中的易用性要优于 C++ 和 Ruby，另外 Dart 是静态类型语言，并且易于编写、修改和维护。最后一个原因则是 Dart 可以编译为 JavaScript，能够很好的利用 node-sass 的生态系统。\n拥抱 dart-sass 前文有提到过，Ruby Sass 需要用户安装 Ruby 才能使用，这对非 Ruby 用户相当不友好，而 node-sass 是基于 Node 封装的，所以后来慢慢地大家都开始用 node-sass 代替 Ruby Sass。\n而 node-sass 的安装过程如下：\n   校验本地 node_modules 中是否已安装 node-sass，版本是否一致;\n  如未安装或版本不符，从 npm 源拉取 node-sass 代码;\n  检测全局缓存和本地中是否有 binding.node,如有即跳过安装;\n  没有 binding.node 则从 github 下载该二进制文件并将其缓存到全局;\n  假如 binding.node` 下载失败，则尝试本地编译出该文件（这个过程需要 Python）;\n  将版本信息写到 package-lock.json;\n   事实上每次安装 node-sass 都会卡在下载 binding.node 这一步，这是因为这个文件放在被墙的服务器上，所以几乎没有办法直接安装成功。\n如果你去百度搜索 node-sass 安装失败，就会发现搜索结果前十几页清一色都在解释失败原因和解决方案，这足以证明安装 node-sass 简直是国内广大前端开发者很难绕开的一个坑。\n而解决这个问题的思路也大致相同：手动下载这个文件，并设置环境变量指向该文件，这样就不会下载而是直接利用本地的 binding.node 文件，或者指定下载这个文件的网址为淘宝镜像源。\n尽管我们有了解决办法，可这种方案多多少少有一种 hack 的成分。\n好在 Sass 官方发布了新一代的 dart-sass，让我们可以直接跳过这个问题，而且使用方式和之前的 node-sass 几乎一模一样，\n安装 dart-sass 也很简单：\n1 2 3 4  # 如果项目中已经安装了 node-sass，需要先卸载掉 npm unsinstall node-sass npm install sass -S -D   vue-cli 支持 dart-sass 如果你是 Vue.js 开发者，不知道有没有注意到 vue-cli 已经默认使用 dart-sass 作为 sass 实现（相关 PR），也就是现在 Vue-CLI 在选择 sass 预处理器的时候也默认使用的 dart-sass\n在 Vue 项目中，安装 dart-sass 也相当方便：\n1  npm install -D sass-loader sass   同样的，如果之前安装过 node-sass 的话，需要将其卸载：\n1  npm uninstall node-sass   语法不兼容 替换 node-sass 之后有一个地方需要注意，就是它不再支持之前 sass 的那种 /deep/ 写法，需要统一改为 ::v-deep 的写法。相关： issue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  .a { /deep/ { .b { color: red; } } } // 修改为 .a { ::v-deep { .b { color: red; } } }   ","description":"抛弃 node-sass，拥抱 dart-sass","id":5,"section":"posts","tags":["sass","node-sass","dart-sass"],"title":"抛弃 node-sass，拥抱 dart-sass","uri":"https://webjam.cn/posts/2020/node-sass-to-dart-sass/"},{"content":"title title 相关的 npm 包：\n commander: 定义命令，解析命令 inquirer: 做出交互，如提问 chalk: 命令行输出五颜六色的字体 ora: loading 效果、图标  chalk 基本使用 1 2 3 4 5 6 7  const chalk = require(\u0026#39;chalk\u0026#39;) console.log(\u0026#39;hello chalk\u0026#39;) console.log(chalk.red(\u0026#39;hello, chalk\u0026#39;)) console.log(chalk.red.bgBlue(\u0026#39;hello, chalk\u0026#39;))   一个 cli 工具的基本工作流程  输入初始化命令 执行交互代码 与用户交互 根据用户指令下载模板 模板下载完成  ","description":"使用 Node.js 构建自己的脚手架","id":6,"section":"posts","tags":["nodejs","脚手架"],"title":"使用 Node.js 构建自己的脚手架","uri":"https://webjam.cn/posts/2020/create-my-cli-with-nodejs/"},{"content":"搭建（开发）过网站的同学应该都知道，一个网站往往要依赖一些第三方库，例如 jQuery、BootStrap、Vue.js 等等，但是依赖的第三方库数量多了之后，难免会拖慢网站的打开速度，这时候适当的引入 CDN 服务是一个很好的策略。\n CDN 的全称是 Content Delivery Network，即内容分发网络。\nCDN是什么？使用CDN有什么优势 - 知乎\n什么是CDN？- 知乎\n 使用 CDN 有这些好处：\n 降低主站的压力：带宽压力和服务器请求压力 增加并发请求数量：浏览器对同一个域名并发请求数量有限制，使用 CDN 会将请求分散到多个域名下，这样同一时间就可以发出更多的请求 更快速的资源响应速度：请求 CDN 资源得到响应的速度，一般是比自己的服务器要快的。  BootCDN 网址：BootCDN\n Bootstrap 中文网开源项目免费 CDN 加速服务 - 我们致力于为 Bootstrap、jQuery、Angular、Vue.js 一样优秀的开源项目提供稳定、快速、免费的 CDN 加速服务。BootCDN 是运营时间最长、用户量最大、最早同时支持 HTTPS（SSL）和 HTTP/2.0 协议的中立免费 CDN 。\n jsDelivr 网址：jsDelivr\njsDelivr 提供 npm，GitHub，WordPress 等项目的镜像。也就是说开发者托管在 GitHub 的代码、发布到 npm 的项目、发布到 WordPress.org 的项目（插件或主题）等文件，都可以使用 jsDelivr 的 cdn 加速功能。\n其他的 cdn 托管的大都是知名开源前端库，而个人开发者想要让自己的文件也享受 cdn 服务，除了使用专业的 cdn 服务（如七牛云、又拍云）之外，还有一个很好的选项就是把文件托管到 GitHub，使用 jsDelivr 的加速服务。\njsDelivr 具体的使用规则略微复杂，可以参考：jsDelivr 为开发者提供免费公共 CDN 加速服务\nCDNJS (by CloudFlare) Everyone loves the Google CDN right? Even Microsoft runs their own CDN.\nThe problem is, they only host the most popular libraries.\nWe host it all - JavaScript, CSS, SWF, images, etc!\n此仓库通过GitHub接受Fork和PR。地址：https://github.com/cdnjs/cdnjs\n360 前端静态资源库 网址：360 前端静态资源库\n 360 前端静态资源库是由奇舞团支持并维护的开源项目免费 CDN 服务，支持 HTTPS 和 HTTP/2，囊括上千个前端资源库和 Google 字体库。\n本站静态资源库数据均同步于 cdnjs，如发现版本更新不及时或未收录，欢迎向 cdnjs 提交 PR。\n 其他 国内还有一些机构提供了前端静态资源的 CDN 服务，但是因为资源数量比较少，就不是特别常用了。\n 新浪云计算CDN公共库 又拍云JS库CDN服务 七牛云存储 开放静态文件CDN  加一道保险 当然，单纯依赖于第三方的 CDN 都是不保险的，所以你可以给自己的网站添加一层保险：在 CDN 读取失败的时候从自己服务器获取对应的文件。\n一般来说，JS 库都会向外暴露一个全局变量，根据是否存在这个全局变量从而判断出 cdn 资源是否加载成功。如果加载失败，就创建 script 标签从自己的服务器加载资源。示例代码如下：\n1 2 3 4 5 6 7 8  \u0026lt;script src=\u0026#34;//cdn.staticfile.org/jquery/1.8.3/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; if (!window.jQuery) { var script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#34;/js/jquery.min.js\u0026#34;; document.body.appendChild(script); } \u0026lt;/script\u0026gt;   结语 祝小伙伴用上 CDN 之后，网站打开速度飞起！\n","description":"","id":7,"section":"posts","tags":["前端","CDN"],"title":"说一下我常用的前端 CDN 加速服务","uri":"https://webjam.cn/posts/2020/cdn-hosts-for-front-end-projects/"},{"content":"与 hexo clean 类似的命令是 hugo \u0026ndash;gc \u0026ndash;cleanDestinationDir\n在 Hugo 中，没有 hexo d 一键部署 public 文件夹到 GitHub 的操作，你需要自己新建脚本，但我建议使用 Git 管理整个站点，然后上传整个站点到 GitHub 以通过持续集成的方式部署，而非用 Git 直接部署 public 生产版代码，因为这其实是非常可笑的——Git 是用来管理源码的。\n启动服务 1  hugo server   由于默认生成的文章模板里面有 draft: false，故需加上 -D 参数才能渲染草稿：\n1  hugo server -D   生成静态文件 1  hugo   生成的静态文件存放 public 文件夹中。\n添加 --minify 参数可以在编译过程中压缩 HTML、JS、CSS 等文件：\n1  hugo --minify   ","description":"","id":8,"section":"posts","tags":["hugo"],"title":"Hugo 常用命令备忘","uri":"https://webjam.cn/posts/2020/hugo-commands/"},{"content":"什么是 BFC  BFC 是 Block Formatting Context 的缩写，翻译成中文就是“块格式化上下文”\n BFC 是一种规则，隔离保护作用\nBFC 是用来解决各种问题的\n例如，很多网站的广告部分就是 BFC 布局，广告关闭之后不能影响整体布局\n广告一般是定位实现的\nBFC 是一块区域，是一个完全封闭的区域，区域内部的元素无论如何布局（定位或者浮动），都对外部没有任何影响。\nBFC 元素具有的特性  在 BFC 中，盒子从顶端开始垂直地一个接一个地排列（块状元素） 盒子垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠 在 BFC 中，每个盒子的坐外边距 margin-left 会触碰到容器的左边缘 border-left BFC 的区域不会与浮动盒子产生交集，而是紧贴浮动边缘 计算 BFC 的高度时，自然也会检测到浮动的盒子高度  BFC 是一个独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level box 如何布局，并且与这个区域外部毫不相干。\nBFC 的作用之清除浮动 基于 BFC 的特性，即 xxxx，所以我们只要把父元素设置 BFC 就可以清除子元素的浮动。\n最简单的做法就是给父元素设置 overflow: hidden。\n例如：\n1 2 3 4  /* style.css */ .fl { float: left; } .fr { float: left; } .o { overflow: hidden; }   1 2 3 4  \u0026lt;div class=\u0026#34;bfc-box o\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl\u0026#34;\u0026gt;左浮动\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fr\u0026#34;\u0026gt;右浮动\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   BFC 的作用之解决外边距塌陷 常见的 BFC 实现方式总结 常见的创建块格式化上下文的方式有很多，这里列举几种我认为比较常见的：\n 根元素(\u0026lt;html\u0026gt;) 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值） overflow 值不为 visible 的块元素 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素） 网格元素（display 为 grid 或 inline-grid 元素的直接子元素）   结语 其实看到最后你会发现，不管在此之前知不知道 BFC 这个概念，我们在布局的时候已经无意识地在利用 BFC 来实现各种需求了。而了解 BFC 的概念之后，突然有一句话出现在脑海中：知其然知其所以然，以前只知道这样可以清除浮动或者那样可以解决外边距塌陷，只知道这是前人总结出的经验，但具体是什么原理却从来没有深入思考过。希望能通过这一个小小的概念，由点及面，让我们在以后的学习过程中能透过表面看到内在原理。\n在写这篇文章参考了以下文章，致谢。\n 块格式化上下文 - MDN  ","description":"","id":9,"section":"posts","tags":["css","bfc"],"title":"CSS 中的 BFC 到底是什么？","uri":"https://webjam.cn/posts/2020/what-is-the-bfc-in-css/"},{"content":"先说单行省略 1 2 3  \u0026lt;div class=\u0026#34;elip w100\u0026#34; style=\u0026#34;border: 1px solid #5184f6;\u0026#34;\u0026gt; 先说单行省略先说单行省略先说单行省略先说单行省略 \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9  /* 单行文本溢出省略 */ .elip { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .w100 { width: 100px; }   效果如下：\n\r.elip {\roverflow: hidden;\rwhite-space: nowrap;\rtext-overflow: ellipsis;\r}\r.w100 {\rwidth: 100px;\r}\r\r先说单行省略先说单行省略先说单行省略先说单行省略\r\r要想实现单行文本超出宽度省略，需要满足以下几点\n 指定一个宽度 超出省略（overflow: hidden;） 不能换行（white-space: nowrap;） 溢出省略（text-overflow: ellipsis;）  单行文本溢出省略很容易实现，但是要想实现多行文本溢出省略就会复杂得多。\n多行文本溢出省略 之所以说多行文本溢出省略不容易实现，是因为在 CSS 规范中 text-overflow: ellipsis 只适用于单行文本，同时并没有适用于多行文本溢出省略的规则。因此我们只能另辟蹊径来实现这个需求。\n浏览器私有属性 1 2 3 4 5 6 7  .box { width: 200px; overflow: hidden; display: -webkit-box; /* 类似于 flexbox 的自适应布局 */ -webkit-box-orient: vertical; /* 元素排列方向：从上到下 */ -webkit-line-clamp: 4; /* 第四行后开始省略 */ }    \r.box {\rwidth: 200px;\roverflow: hidden;\rdisplay: -webkit-box; /* 类似于 flexbox 的自适应布局 */\r-webkit-box-orient: vertical; /* 元素排列方向：从上到下 */\r-webkit-line-clamp: 4; /* 第四行后开始省略 */\r}\r\r多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略\r多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略\r多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略\r多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略\r\r这种方法的优点是写法简洁明了，但缺点就是通过私有属性实现，兼容性不好。\n ","description":"","id":10,"section":"posts","tags":["css","文本溢出"],"title":"CSS多行文本溢出省略","uri":"https://webjam.cn/posts/2020/css-text-overflow-ellipsis/"},{"content":"docker 安装 直接执行脚本即可：\n1  curl -fsSL https://get.docker.com -o get-docker.sh \u0026amp;\u0026amp; sudo sh get-docker.sh   查看Docker的版本\n1  docker version   安装 docker-compose 直接执行脚本即可：\n1  curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose   安装完成之后设置权限\n1  chmod +x /usr/local/bin/docker-compose   查看Docker Compose的版本\n1  docker-compose version   ","description":"","id":11,"section":"posts","tags":["docker","docker-compose"],"title":"docker 和 docker-compose 的安装","uri":"https://webjam.cn/posts/2020/docker-install/"},{"content":"安装 Hugo Hugo 是用 Go 语言写的，支持多个平台，而且官方提供了构建好的二进制文件，只需要下载合适你系统版本的 Hugo 二进制文件即可。\n为了方便使用，建议把它安装到你的 PATH 环境变量所在的位置。\n在 macOS 上还可以通过命令进行安装：\n1  brew install hugo   生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径：\n1  $ hugo new site /path/to/site   这样就在 /path/to/site 目录里生成了初始站点，进去目录：\n1  $ cd /path/to/site   站点目录结构：\n ▸ archetypes/\r▸ content/\r▸ layouts/\r▸ static/\rconfig.toml\r创建文章 创建一个 about 页面：\n1  $ hugo new about.md   about.md 自动生成到了 content/about.md ，打开 about.md 看下：\n1 2 3 4 5 6 7 8  +++ date = \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;about\u0026#34; +++ 正文内容   内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 \u0026mdash; 标记）或者 JSON 格式。\n创建第一篇文章，放到 post 目录，方便之后生成聚合页面。\n1  $ hugo new post/first.md   打开编辑 post/first.md ：\n1 2 3 4 5 6 7 8 9 10 11  --- date: \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; title: \u0026#34;first\u0026#34; --- ### Hello Hugo  1. aaa 1. bbb 1. ccc   安装皮肤 到 皮肤列表 挑选一个心仪的皮肤，比如你觉得 Hyde 皮肤不错，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来：\n1 2 3  # 创建 themes 目录 $ cd themes $ git clone https://github.com/spf13/hyde.git   运行Hugo 在你的站点根目录执行 Hugo 命令进行调试：\n1  $ hugo server --theme=hyde --buildDrafts   （注明：v0.15 版本之后，不再需要使用 \u0026ndash;watch 参数了）\n浏览器里打开： http://localhost:1313\n部署 假设你需要部署在 GitHub Pages 上，首先在 GitHub 上创建一个 Repository，命名为：coderzh.github.io （coderzh替换为你的github用户名）。\n在站点根目录执行 Hugo 命令生成最终页面：\n1  $ hugo --theme=hyde --baseUrl=\u0026#34;http://coderzh.github.io/\u0026#34;   （注意，以上命令并不会生成草稿页面，如果未生成任何文章，请去掉文章头部的 draft=true 再重新生成。）\n如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的 Repository 的 master 分支。\n1 2 3 4 5 6  $ cd public $ git init $ git remote add origin https://github.com/coderzh/coderzh.github.io.git $ git add -A $ git commit -m \u0026#34;first commit\u0026#34; $ git push -u origin master   浏览器里访问：http://coderzh.github.io/\n","description":"","id":12,"section":"posts","tags":["hugo"],"title":"Hugo Quick Start","uri":"https://webjam.cn/posts/2020/hugo-quick-start/"},{"content":"[toc]\n基本类型和引用类型 先来看看 JavaScript 中两种数据类型有何异同。\n基本类型和引用类型的保存方式不同。\n基本数据类型是按值访问的。基本数据类型的值保存在栈内存中，可以直接对其操作。基本数据类型包含 5 种：Undefined、 Null、 Boolean、Number 和 String。\n引用类型的值是按引用访问的。引用类型的值保存在堆内存中，另外在栈内存中会有一个引用指针指向堆内存中的对象，变量中保存的实际上是一个指针。在操作对象时，实际上是在操作对象的引用指针而不是实际的对象。\n另外，基本类型和引用类型的复制方式也不同。\n如果从一个变量向另一个变量复制基本类型的值，会在栈内存中创建一个新值，然后把值复制到新变量的位置上。例如：\n1 2  var num1 = 5; var num2 = num1;   现在，将 num1 的值复制给 num2 ，两个变量中的值相同，但是 num2 的值只是 num1 的值的一个副本，因此两者是相互独立的，不会互相影响。\n当一个变量向另一个变量复制引用类型的值，同样也会将储存在变量中的值复制一份到为新变量分配的空间中。但是这个值实际上是一个指针，指向储存在堆内存中的一个对象。复制结束后，两个变量存储的指针指向同一个对象，因此改变其中一个变量，就会影响到另一个变量。\n1 2 3 4  var obj1 = { name: \u0026#39;js\u0026#39; } var obj2 = obj1; obj2.name = \u0026#39;jquery\u0026#39;; console.log( obj1.name ); // jquery   由此可见，基本数据类型的复制非常简单，直接使用赋值运算即可，无副作用。然而引用类型的复制则不能直接使用赋值运算，否则操作的仍是同一个对象，毫无意义。\n故下面讨论的拷贝都是针对引用数据类型而言。\n浅拷贝 demo 我们说的复制，其实就是希望得到一个和原有对象有相同键值对集合（属性）的新对象，那么我们可以直接遍历对象，将键值对都储存在一个新的对象下，这样新对象和原对象就有一样的键值对集合（属性），也就达到我们的目标。\n等一下，这里有个问题，如果某个属性值为引用类型，储存的值为对应的引用指针，则仍然会出现新变量和原有变量相互影响的问题。\n以数组为例，若数组中元素都为基本数据类型：\n第一步，遍历原数组，单独拷贝其中元素：\n1 2 3 4 5 6 7 8  var arr = [ 1, 2, 3 ]; var newArr = []; arr.forEach(function (item, index) { newArr[index] = item; }) console.log(arr); // [1, 2, 3] console.log(newArr); // [1, 2, 3]   第二步，修改新数组：\n1 2 3 4  newArr.push(4); console.log(arr); // [1, 2, 3] console.log(newArr); // [1, 2, 3, 4]   可以看到，修改 newArr ，原数组 arr 并未发生修改。\n同样以数组为例，若数组中存在引用类型的元素：\n第一步，遍历进行拷贝\n1 2 3 4 5 6 7 8  var arr = [ 1, 2, [ 3, 4 ] ]; var newArr = []; arr.forEach(function (item, index) { newArr[index] = item; }) console.log(arr); // [1, 2, [3, 4]] console.log(newArr); // [1, 2, [3, 4]]   第二步，修改新数组中嵌套的数组\n1 2 3 4  newArr[2].push(5); console.log(arr); // [1, 2, [3, 4, 5]] console.log(newArr); // [1, 2, [3, 4, 5]]   我们发现，无论是 arr 还是 newArr 都发生了变化。\n当属性值为基本数据类型时，我们拷贝出来的新对象和原对象互不影响，当属性值为引用类型时，新对象和原对象在修改引用类型的属性值时相互影响。\n所以说这种拷贝方式不够彻底，即浅拷贝。\n总结浅拷贝的方法 现在我们封装一个同时适用于 Array 和 Object 类型的浅拷贝的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function shallowCopy (obj) { if (typeof obj !== \u0026#39;object\u0026#39;) return obj; var newObj = obj instanceof Array ? [] : {}; for (var key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key]; } } return newObj; }   注意几点：\n 只拷贝引用类型，基本数据类型直接返回即可 根据 obj 的类型来判断新建一个空数组或者空对象 遍历时，使用 hasOwnProperty() 过滤出对象实例的属性  总结深拷贝的方法 上面演示了浅拷贝，浅拷贝存在的问题是引用类型的属性也是引用类型，但其实最终引用类型的键值也是由基本类型组成的。\n如 var person = { name: 'jake' } 中 person 是引用类型，但是 person 的属性名和属性值都是基本类型。\n所以如果我们对其进行递归浅拷贝，总会拷贝到键值均为基本数据类型的那一步。\n具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function deepCopy (obj) { if ( typeof obj !== \u0026#39;object\u0026#39; ) return obj; var newObj = obj instanceof Array ? [] : {}; for ( var key in obj ) { if ( obj.hasOwnProperty( key ) ) { newObj[key] = typeof obj[key] === \u0026#39;object\u0026#39; ? deepCopy( obj[key] ) : obj[key]; } } return newObj; }   现在我们来测试一下：\n1 2 3 4 5 6 7  var arr = [ 1, 2, [ 3, 4 ] ]; var newArr = deepCopy(arr); newArr[2].push(5); console.log( arr[2] ); // [3, 4] console.log( newArr[2] ); // [3, 4, 5]   此时尽管 arr 中有引用类型的元素，通过深拷贝（递归浅拷贝）得到新对象 newArr 之后，修改其引用类型的属性可以发现，arr 和 newArr 不再互相影响，所以这种递归拷贝的方式叫做深拷贝。\n封装深浅拷贝的方法 上面分别总结了浅拷贝和深拷贝的方法，但是这两个方法的功能以及代码都有很大的相似度，我们可以考虑将它们封装成一个方法，通过多传入一个参数区分深拷贝和浅拷贝，如：extend( [deep], obj )。\n大致思路如下：\n 第一个参数 deep 为布尔类型，区分深浅拷贝，可忽略，忽略时视为浅拷贝（即默认值 false） 如果传入参数 deep 那么第二个参数是拷贝的目标对象，如果忽略 deep 参数，那么第一个参数就是拷贝的目标对象。 在为新建空对象的拷贝属性时，通过 deep 判断是否进行深拷贝。  代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function extend() { var deep = false; var target = arguments[0]; var newObj, copy; if ( typeof target == \u0026#39;boolean\u0026#39; ) { deep = target; target = arguments[1]; } newObj = target instanceof Array ? [] : {}; if ( typeof target !== \u0026#39;object\u0026#39; ) return target; for ( var key in target ) { if ( target.hasOwnProperty( key ) ) { copy = target[ key ]; newObj[key] = deep \u0026amp;\u0026amp; typeof copy === \u0026#39;object\u0026#39; ? extend(deep, copy) : copy; } } return newObj; }   以数组为例测试一下：\n1 2 3 4 5 6 7 8 9  var arr = [ 1, 2, [ 3, 4 ] ]; var newArr = extend(false, arr); var newArr2 = extend(true, arr); newArr[2].push(5); console.log( arr[2] ); // [1, 2, [3, 4, 5]] console.log( newArr[2] ); // [1, 2, [3, 4, 5]] console.log( newArr2[2] ); // [1, 2, [3, 4]]   和预期一样，Good Job!\n参考资料：\n  JavaScript 高级程序设计\n  for\u0026hellip;in · MDN\n  Object.prototype.hasOwnProperty() · MDN\n  How to Deep clone in javascript · stackoverflow\n  How do I correctly clone a JavaScript object? · stackoverflow\n  ","description":"","id":13,"section":"posts","tags":["js"],"title":"JavaScript 之深浅拷贝","uri":"https://webjam.cn/posts/2020/clone-object-in-javascript/"},{"content":"来来来，文章开始之前，先回一个问题：0.1 + 0.2 的结果是多少？\n","description":"","id":14,"section":"posts","tags":["浮点数","精度"],"title":"JavaScript 浮点数的精度问题","uri":"https://webjam.cn/posts/2020/the-precision-of-floating-number-in-javascript/"},{"content":"按钮级别权限控制 路由（页面）级别权限控制 路由级别的权限控制，主要依赖 vue-router 的几个路由钩子函数。vue-router 的路由钩子主要有以下几项\n","description":"","id":15,"section":"posts","tags":["vue","permission","权限"],"title":"Vue 项目中权限控制的几种方法","uri":"https://webjam.cn/posts/2020/manage-permission-in-vue-project/"},{"content":"滚动条相关伪类 可以使用以下伪元素选择器去修改各式webkit浏览器的滚动条样式:\n ::-webkit-scrollbar — 整个滚动条 ::-webkit-scrollbar-button — 滚动条上的按钮 (上下箭头) ::-webkit-scrollbar-thumb — 滚动条上的滚动滑块 ::-webkit-scrollbar-track — 滚动条轨道 ::-webkit-scrollbar-track-piece — 滚动条没有滑块的轨道部分 ::-webkit-scrollbar-corner — 当同时有垂直滚动条和水平滚动条时交汇的部分 ::-webkit-resizer — 某些元素的corner部分的部分样式(例:textarea的可拖动按钮)  代码段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /* 滚动条整体样式 */ ::-webkit-scrollbar { width: 1rem; height: 1rem; background:hsla(0,0%,100%,.4); } /* 滚动条轨道 */ ::-webkit-scrollbar-track { border-radius: 0; } /* 滑块部分 */ ::-webkit-scrollbar-thumb { border-radius: 0; /* background-color: rgba(81,132,246, .3); */ background: linear-gradient(180deg, #6e2ee5, #5184f6); -webkit-transition:background-color .1s; transition:background-color .1s; border-radius: 30px; box-shadow: inset 2px 2px 2px hsla(0, 0%, 100%, .25), inset -2px -2px 2px rgba(0, 0, 0, .25); } ::-webkit-scrollbar-thumb:hover { background-color: rgba(81,132,246, .5); } /* 滚动条里面轨道 */ ::-webkit-scrollbar-track { background: linear-gradient(90deg, #f2f2f2, #f2f2f2 1px, #f2f2f2 0, #f2f2f2); }   ","description":"","id":16,"section":"posts","tags":["css","滚动条"],"title":"代码段 | 自定义浏览器滚动条样式","uri":"https://webjam.cn/posts/2020/custom-styles-of-browser-scroll-bar/"},{"content":" NPM 的全称：Node Package(包) Manager(管理器)。\n NPM 是什么 如何发布 NPM 关键字段 NPM 包的配置主要都在 package.json 中，这个文件中有很多重要的字段\n1 2 3 4 5 6 7 8 9 10 11 12  { \u0026#34;name\u0026#34;: \u0026#34;node package\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.1.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;npm run serve\u0026#34;, }, \u0026#34;dependencies\u0026#34;: { }, \u0026#34;devDependencies\u0026#34;: { } }   命名空间 在终端登录 忽略文件配置 .npmignore\n新建一个文件，名为.npmignore，是不需要发布到npm的文件和文件夹，规则和.gitignore一样。如果你的项目底下有.gitignore但是没有.npmignore，那么会使用.gitignore里面的配置\n1 2 3 4 5 6 7  .* *.md *.yml build/ node_modules/ src/ test/   版本号的知识 major，minor 或者 patch\n","description":"","id":17,"section":"posts","tags":["npm"],"title":"发布 NPM 包的正确姿势","uri":"https://webjam.cn/posts/2020/publish-your-node-package/"},{"content":"经常出入掘金社区 (juejin.im) 的朋友可能会留意到个人主页的个人头像上面有一个动画效果，是一个旋转动画，而且能越转越快。感觉这个动画挺有意思，所以就专门研究学习一下。\n观察 对头像进行了多次研究（调戏）之后，我发现这个动画有几个特点：\n 延迟：这个动画会在鼠标移入 1 秒左右开始执行 转速：头像旋转的速度由慢到快，越来越快 持续时间：动画开始执行之后，除非把鼠标移出，否则会在几十秒之后结束动画。  实现 使用 F12 大法（即使用 Chrome 开发工具审查元素样式），我得到了动画的实现方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13  /* 基础样式 */ img { width: 100px; height: 100px; border-radius: 50%; } /* 鼠标移入时动画 */ img:hover { transition-delay: 1s; transition-duration: 59s; transform: rotate(666turn); transition-timing-function: cubic-bezier(.34, 0, .84, 1); }   关于这几个 CSS 属性的理解：\n transition-delay 是动画延迟，也就是说 1s 之后才开始执行动画 transition-duration 是动画持续时间，这里就是 59s 动画执行完毕 transform: rotate(666turn); 是动画的结果（累积的效果）：旋转 666turn。一个 turn 就是一圈（360deg），这里就是要将图片旋转 666 圈 transition-timing-function 用来规定规定过渡效果的时间曲线，也就是动画的运动效果（比如先慢后快），具体的值是 cubic-bezier(.34, 0, .84, 1) ，这叫做的“贝塞尔曲线”，根据它的取值来决定动画旋转的速度变化。  关于 turn 的资料很少，只有 CSS turn详解-CSS角度值与单位 明确说了是一圈，以及 transform - CSS（层叠样式表） | MDN 有一个 turn 的示例\n示例 请将你的鼠标移入下图查看效果（鼠标移入 1 秒之后开始执行动画）\n\r#rotate-demo:hover {\rtransition-delay: 1s;\rtransform: rotate(666turn);\rtransition-duration: 59s;\rtransition-timing-function: cubic-bezier(.34, 0, .84, 1);\r}\r\r结语 技术无止境，CSS 也是博大精深，利用 transform 属性可以做出很多炫酷的效果，这里就先说这些，点到为止，本文全当抛砖引玉，更多的内容还需要您去研究去探索。\n","description":"","id":18,"section":"posts","tags":["css","动画"],"title":"掘金头像旋转动画实现","uri":"https://webjam.cn/posts/2020/rotate-your-avatar-as-juejin/"},{"content":"手写 Promise\n","description":"","id":19,"section":"posts","tags":["promise","异步"],"title":"深入理解 Promise（三）— 实现自己的 Promise","uri":"https://webjam.cn/posts/2020/2020-06-20-promise-03-wirte-a-promise/"},{"content":"Promise 是一个构造函数，它的使用方式如下：\n1 2 3 4  new Promise(function (resolve, reject) { // resolve(value)  // reject(reason) })   Promise 接收一个函数作为参数，这个函数有两个参数（函数类型的参数），分别是 resolve 和 reject。\n执行 resolve 时，Promise 状态由 pending 改为 fulfilled ；执行 reject 时，Promise 状态由 pending 改为 rejected\nPromise 静态方法 Promise.resolve(param) 等同于是 new Promise(function (resolve, reject) { resolve(param) }) ，也就是立即将 Promise 的状态设置为 resolve\nPromise.reject(reason) 等同于是 new Promise(function (resolve, reject) { reject(param) }) ，也就是立即将 Promise 的状态设置为 rejected\nPromise.all([p1, \u0026hellip;, pn]) 输入一组 promise 返回一个新的 promise，这组 promise 全部都是 fulfilled 状态 Promise.all 才是 fulfilled 状态\nPromise.allSettled([p1, \u0026hellip;, pn]) 输入一组 promise 返回一个新的 promise，这组 promise 的状态全部改变之后，Promise.allSettled 编程 fulfilled 状态\nPromise.race([p1, \u0026hellip;, pn]) 输入一组 promise 返回一个新的 promise， 结果 promise 的状态跟随第一个变化的 promise 状态\nPromise 实例方法 promise.then(onFulfilled, onRejected) promise 状态改变之后的回调，返回新的 promise 对象\npromise.catch(function (reason) {}) promise 状态为 rejected 的回调\npromise.finally(function(reason) {}) 不管 promise 是什么状态，都会执行\n 注意点\n then、catch 返回的 promise 都是新的 promise，不是原来的 promise Promise 对象的错误会“冒泡”，知道被捕获位置，错误会被下一个 catch 语句捕获。   实践 最佳实践\n 不要忘记 catch 捕捉错误 then 方法中使用 return 传递函数给 then 方法 不要把 promise 写成嵌套   题目：\n3 秒之后亮一次红灯，再过 2 秒亮一次绿灯，再过 1 秒亮一次黄灯，用 promise 实现多次交替亮灯的效果\n用 console.log 模拟亮灯\n ","description":"","id":20,"section":"posts","tags":["promise","异步"],"title":"深入理解 Promise（二）— ES6 Promise API","uri":"https://webjam.cn/posts/2020/2020-06-19-promise-02-es6-promise-api/"},{"content":"Promise/A+规范 术语\n Promise: 一个有 then 方法的对象或者函数，行为符合本规范 thenable: 一个定义了 then 方法的对象或函数 value: 值，任何 JavaScript 的合法值 execption: 异常，throw 语句抛出的值 reason: 拒绝原因， 一个标识 promise 被拒绝原因的值  promise 有三个状态\n pending 表示等待 fulfilled 表示完成 rejected 表示拒绝  ","description":"","id":21,"section":"posts","tags":["promise","异步"],"title":"深入理解 Promise（一）— Promise/A+ 规范","uri":"https://webjam.cn/posts/2020/2020-06-18-promise-01-promise-standard/"},{"content":"JavaScript 中有六种基本数据类型：Number, String, Boolean, Undefined, Null, Symbol(在 ES6 中新增)，除此之外还有一种复杂数据类型 Object。\n今天我们聊聊其中的一种类型：Undefined。\n先来说说什么是 undefined 当一个变量被定义却没有被赋值的时候，它的初始值就是 undefined，或者在一个函数执行时没有传入对应对实参，那么这个参数的的值就是 undefined。\n为什么说 undefined “不可靠” 为什么说我说 undefined 是“不可靠”的呢？因为 undefined 是可以被人为修改的。\n不信你看：\n1 2 3 4 5 6  function fn () { var undefined = 1 console.log(undefined) } fn() // 1   在函数 fn 中，定义了一个变量 undefined 并赋值为 1，在此之后所有的 undefined 的值就变成了 1，而不是一开始所说的初始值 undefined 了。\n上面的例子是在函数内部定义的变量，其实函数外部也可以将 undefined 定义为一个变量。\n1 2  var undefined = 1 // Chrome undefined; IE8 1 console.log(undefined)   幸运的是，这种写法只在 IE8 上面才生效，Chrome 浏览器中无法生效。在 Chrome 中 undefined 的值就是 undefined 无法被修改（但第一个函数的例子仍然可以在 Chrome 中生效）。\n之所以有这种现象，是因为 undefined 不是 JavaScript 的保留字或关键字，所以 undefined 可以被当作变量名使用，考虑到这种这种被当做变量名使用的情况，如果我们在开发中直接使用 undefined 就可能会有风险了（有可能某个插件中篡改了 undefined 的值）。\n如何准确地获取 undefined 考虑到上面 undefined 被重新赋值的情况，我们就需要找到能够得到“真实”的 undefined 的方法。下面是我想到的几个方法：\n1. 变量被定义，但是没有被赋值 根据 undefined 的定义，如果一个变量被创建了却没有赋予它一个值，那这个变量的值就是 undefined，这里在一个匿名函数中创建一个变量，但不给它赋值，而是直接将它作为函数返回值，通过匿名函数立即执行的方式得到真实的 undefined 值。\n1 2 3 4 5 6  var result = (function () { var a; return a; })() console.log(result); // undefined   2. 函数参数的缺省值是 undefined 这也是根据 undefined 的产生规则，一个函数在执行时，如果它的一个参数没有被传值，那这个参数的值就是 undefined。\n1 2 3 4 5  var result = (function(a) { return a; })() console.log(result); // undefined   3. 函数默认返回值是 undefined。 这是根据函数返回值的规则，如果函数没有 return 语句或者 return 没有指定具体的值，默认函数的返回值就是 undefined。\n1 2 3  var result = (function () {})() console.log(result); // undefined   4. 最简洁易用的写法 这个是在看 underscore源码 的时候学到的，相比上面几种方法，这种写法非常简洁，而且也更容易使用，非常推荐使用这种方法。\n1 2 3  // 这两种方式相同，且开销最小 console.log( void(0) ) // undefined console.log( void 0 ) // undefined   一些 JS 库的做法 这里主要参考了 underscore 和 jQuery 插件的做法\n在 underscore 中有一个用来判断是否为 undefined 的工具函数（源码在此）\n1 2 3  _.isUndefined = function(obj) { return obj === void 0; };   可以看到 underscore 使用了 void 0 的方法\njQuery 的插件中经常会使用下面结构来包裹代码\n1 2 3  ;(function($, doc, win, undefined) { // some code })(jQuery, document, window)   这则是利用函数中不给参数传值，该参数就是 undefined 的规则来实现的。\n总结  牛顿年老时写道：“我并不知道我在世人眼中是什么模样，对我来说，我似乎只像是一个在海边玩耍的男孩，不时找一颗平滑的卵石，或是比较美丽的贝壳来取悦自己，而真理的大海则横陈在我面前，一无发现。”\n 我此刻的感受也是如此，JavaScript 的原理和延伸出来的写法浩如烟海，甚至一个小小的 undefined 都值得细细品味。在真理的大海面前，我似乎也只是一个在海边玩耍的男孩。\n共勉~\n（完）\n参考文章：\n undefined - MDN   ","description":"","id":22,"section":"posts","tags":["js","undefined"],"title":"不可靠的 undefined","uri":"https://webjam.cn/posts/2020/2020-05-14-undefined-untrustworthy/"},{"content":"Markdownify box This is boxmd shortcode Simple box This is **box** shortcode\r Code tabs Make it easy to switch between different code\njava\rjavascript\r\r1  System.out.println(\u0026#39;Hello World!\u0026#39;);   \r\r1  console.log(\u0026#39;Hello World!\u0026#39;);   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"e3ccd48fd780d100\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r Tabs for general purpose Windows\rMacOS\rUbuntu\r\rWindows section 1  console.log(\u0026#39;Hello World!\u0026#39;);   ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\n\rMacOS section Hello world!\r\rUbuntu section Great!\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"11c0a9caaffdb188\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r Expand \r\rExpand me\r\rTitle contents\r\r \r\rExpand me2\r\rTitle2 contents2\r\r Alert Colored box\nthis is a text\rthis is a text\rthis is a text\rthis is a text\rNotice success text\r info text\r warning text\r error text\r ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":23,"section":"posts","tags":["shortcode"],"title":"Shortcodes","uri":"https://webjam.cn/posts/shortcodes/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn: Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":24,"section":"posts","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"https://webjam.cn/posts/markdown-syntax/"},{"content":"We need goldmark katex entension which is not yet we have: [https://github.com/gohugoio/hugo/issues/6544](https://github.com/gohugoio/hugo/issues/6544)\r Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }}\r{{ partial \u0026quot;math.html\u0026quot; . }}\r{{ end }}\r To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$\nBlock math:\n$$\n\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","description":"A brief guide to setup KaTeX","id":25,"section":"posts","tags":null,"title":"Math Typesetting","uri":"https://webjam.cn/posts/math-typesetting/"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"Guide to emoji usage in Hugo","id":26,"section":"posts","tags":["emoji","gamoji","namoji","bamoji","amoji"],"title":"Emoji Support","uri":"https://webjam.cn/posts/emoji-support/"},{"content":"让你的网站支持macOS和IOS的深色模式\n1 2 3 4 5 6 7  @media (prefers-color-scheme: light) { /* 浅色模式样式 */ } @media (prefers-color-scheme: dark) { /* 深色模式样式 */ }   参考文章 https://zhih.me/website-darkmode-on-macos/#\n","description":"","id":27,"section":"posts","tags":["暗黑模式"],"title":"Dark Mode on MacOS","uri":"https://webjam.cn/posts/2020/dark-mode-on-macos/"},{"content":"JavaScript 的参数研究\n缘起 在一次群聊中看到如下的一段代码，要求判断最终的打印结果是什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function getObj (obj) { obj.age = 18; obj = { name: \u0026#39;jason\u0026#39;, age: 26, } return obj; } var p = { name: \u0026#39;bob\u0026#39;, age: 20, } var p2 = getObj(p) console.log(p) console.log(p2)   ","description":"","id":28,"section":"posts","tags":["参数","面试题"],"title":"Arguments in Javascript","uri":"https://webjam.cn/posts/2020/arguments-in-javascript/"},{"content":"使用 cdn 加速你的网站！\n在知乎看到下面两个问题：\n 阿里云服务器1M带宽能承受多少人在线？ 阿里云ECS服务器1M带宽表示什么意思，如何选择服务器带宽？  ","description":"","id":29,"section":"posts","tags":["cdn","前端优化","网站加速"],"title":"Speed Up Your Website With Cdn","uri":"https://webjam.cn/posts/2019/2019-11-29-speed-up-your-website-with-cdn/"},{"content":"Vue.js 插件介绍 Vue.js 插件以一种更优雅的方式来为 Vue 添加全局功能。\n插件的使用方法很简单，只需要在 new Vue() 之前通过 Vue.js 提供的 use 方法来注册（启用）插件即可：\n1 2 3 4 5 6  import MyPlugin from \u0026#34;MyPlugin\u0026#34;; // 要在 new Vue() 之前调用 use 方法 Vue.use(MyPlugin) // 也可以传入一个可选的选项对象 Vue.use(MyPlugin, { someOption: true })   如何自己开发一个插件 上面讲到，通过 Vue.use 方法来注册插件， Vue.use 方法接收两个参数，第一个是插件，第二个是一个可选的选项对象\n1  Vue.use(MyPlugin, { someOption: true })   而 Vue.use 方法执行时是调用由 MyPlugin 提供的 install 方法，因此上面代码相当于：\n1  MyPlugin.install(Vue, { someOption: true })   install 方法接收两个参数，Vue 构造函数和调用插件时传入的可选的选项对象。\n因此，只要是一个向外暴露 install 方法的模块，就可以作为 Vue 的插件，例如：\n1 2 3 4 5  // MyPlugin.js MyPlugin.install = function (Vue, options) { console.log(\u0026#39;hello, MyPlugin\u0026#39;); } export default MyPlugin;   这便是一个最简单的 Vue.js 插件了。\n当然，我们开发插件不可能只是为了打印一句话，而是有更重要的使命等待我们去完成，因为 install 方法第一个参数是 Vue 构造函数，所以你可以围绕着 Vue 来扩展更多更强大的功能，另外 install 第二个参数可以接收一个配置选项对象，这样可以使你提供的功能更加灵活更具有可配置性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  MyPlugin.install = function (Vue, options) { // 1. 添加全局方法或属性  Vue.myGlobalMethod = function () { // 逻辑...  } // 2. 添加全局资源  Vue.directive(\u0026#39;my-directive\u0026#39;, { bind (el, binding, vnode, oldVnode) { // 逻辑...  } }) // 3. 注入组件选项  Vue.mixin({ created: function () { // 逻辑...  } }) // 4. 添加实例方法  Vue.prototype.$myMethod = function (methodOptions) { // 逻辑...  } }   ps: 有的同学担心插件会被多次注册，其实 Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。\nlive demos 我们常见的库 Element UI 也是以插件形式引入，而且组件库内部的单个组件也都是插件形式存在，如 ElButton\n另外，awesome-vue 集合了大量由社区贡献的插件和库，有兴趣的同学可以自行研究学习。\n相关链接：  Element UI 文档 Element UI 源码 插件 - Vue.js 文档  本文完，感谢阅读。😜\n","description":"","id":30,"section":"posts","tags":["vue.js","plugin"],"title":"如何创建一个 Vue.js 插件","uri":"https://webjam.cn/posts/2019/2019-11-28-how-to-create-a-plugin-of-vue.js/"},{"content":"Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\nAxios 有以下特点：\n 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造)  axios 的详细使用都可以在 https://github.com/axios/axios 中看到，本文主要将在项目实践中如何进一步封装 axios ，使得 axios 更符合实际需求。\n封装步骤 全局配置 全局配置是指配置 baseURL timeout 等选项。\n全局配置会影响到每个请求，可以直接对 axios 配置，也可以创建 axios 的实例，对实例进行配置。\naxios 和 axios 实例的区别就在于，axios 可以创建多个实例，不同实例之间的配置可以不同，并且不会影响到 axios 这个源头。\n直接配置 axios：\n1 2  axios.defaults.baseURL = \u0026#39;https://api.example.com\u0026#39;; axios.defaults.timeout = 2000;   或者配置 axios 实例：\n1 2 3 4 5 6 7  import axios from \u0026#34;axios\u0026#34;; // 创建 axios 实例 const request = axios.create({ baseURL: \u0026#34;https://api.example.com\u0026#34;, timeout: 2000, // 请求超时时间 });   拦截器 axios 拦截器分为「请求拦截器」和「响应拦截器」，它们相当于是项目 http 请求的大门。\n每次发送请求时要经过「请求拦截器」这道门，请求得到响应时也要经过「响应拦截器」这道门。\n有了拦截器，方便我们对每个请求进行一些处理，比如：\n 发送请求时，判断用户的登录状态或者用户权限，不满足条件的或者跳转登录页面或者弹窗提示 发送请求时，添加特定的 headers 请求得到响应时，根据响应状态码做不同处理：  200: 响应成功 404: 未找到资源 409: 用户没有相应权限    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  import axios from \u0026#34;axios\u0026#34;; // 创建 axios 实例 const request = axios.create({ baseURL: \u0026#34;https://api.example.com\u0026#34;, timeout: 2000 // 请求超时时间 }); // request 拦截器 request.interceptors.request.use( config =\u0026gt; { // 设置 token，或者其他设置  config.headers[\u0026#34;token\u0026#34;] = \u0026#39;token_123\u0026#39;; return config; }, err =\u0026gt; { return Promise.reject(err) }, ); // response 拦截器 request.interceptors.response.use( resp =\u0026gt; resp.data, error =\u0026gt; { if (error.response) { const data = error.response.data; let msg = data.desc || data.exception || \u0026#39;\u0026#39;; switch (error.response.status) { case 401: // 提示：登录过期，跳转登录页面重新登录  break; case 403: // 提示：权限不足  break; case 404: // 提示：资源不存在  break; default: // 提示：请求失败  break; } } return Promise.reject(error); } );   封装各类型请求 这一步封装主要是为了统一 axios 中不同请求类型的参数要求。\n以 POST 和 GET 为例，封装之前\n1 2 3 4 5 6 7 8  const payload = { ID: 12345 } // get 请求，params 属性值是携带的参数 axios.get(\u0026#39;/user\u0026#39;, { params: payload }) // post 请求 axios.post(\u0026#39;/user\u0026#39;, payload)   封装之后：\n1 2 3 4  const payload = { ID: 12345 } GET(\u0026#39;/user\u0026#39;, payload) POST(\u0026#39;/user\u0026#39;, payload)   封装之后，每种类型的请求方法都接受两个参数：url 和需要传递到服务端的数据 payload。\n这里我封装了 GET POST PUT DELETE 四种方法，分别对应 get post put delete 类型的请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  export function GET (url, payload) { return request.get(url, { params: payload }); } export function POST (url, payload) { return request.post(url, payload); } export function PUT (url, payload) { return request.put(url, payload); } export function DELETE (url, payload) { return request.delete(url, { data: payload }); }   使用方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 示例： import { GET, POST, PUT, DELETE } from \u0026#39;@/utils/request.js\u0026#39; const payload = { username: \u0026#39;admin\u0026#39;, password: \u0026#39;123456\u0026#39; } POST(\u0026#39;/login\u0026#39;, payload) .then(resp =\u0026gt; { // 请求成功  }) .catch(err =\u0026gt; { // 请求失败  }) .finally { // 成功/失败都会执行这里代码  }   其他 post 请求数据格式 默认情况下，axios 中 post 请求的 Content-Type 字段对应的值是 application/json ，此时是以 json 格式向服务端发送数据。\n如果想要以 FormData 形式发送数据，你可以这样解决\n1 2 3 4 5 6 7 8 9 10  import axios from \u0026#34;axios\u0026#34;; import qs from \u0026#39;qs\u0026#39;; const data = { \u0026#39;bar\u0026#39;: 123 }; const options = { url, method: \u0026#39;POST\u0026#39;, data: qs.stringify(data), headers: { \u0026#39;content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, }; axios(options);   那么前面对 POST 方法的封装也要进行修改：\n1 2 3 4 5 6 7 8 9 10  import qs from \u0026#39;qs\u0026#39;; export function POST (url, payload) { const options = { url, method: \u0026#39;POST\u0026#39;, data: qs.stringify(data), headers: { \u0026#39;content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, }; return request(options); }   挂载到 vue 原型上 1 2 3 4 5 6 7  import { GET, POST, PUT, DELETE } from \u0026#39;@/utils/request.js\u0026#39; Vue.prototype.$http = { get: GET, post: POST, put: PUT, delete: DELETE }   挂载到原型上之后，就可以在任意的 vue 组件内通过 vue 实例调用请求：\n1  this.$http.get(\u0026#39;/user\u0026#39;, { id: 123 })   完整代码 \r\r完整的 request.js 代码在此，请点击展开完整代码\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  // request.js import axios from \u0026#34;axios\u0026#34;; // 创建 axios 实例 const request = axios.create({ baseURL: \u0026#34;https://api.example.com\u0026#34;, timeout: 2000, // 请求超时时间 }); // request 拦截器 request.interceptors.request.use( config =\u0026gt; { // 设置 token，或者其他设置  config.headers[\u0026#34;token\u0026#34;] = \u0026#39;token_123\u0026#39;; return config; }, err =\u0026gt; { return Promise.reject(err) }, ); // response 拦截器 request.interceptors.response.use( resp =\u0026gt; resp.data, error =\u0026gt; { if (error.response) { const data = error.response.data; let msg = data.desc || data.exception || \u0026#39;\u0026#39;; switch (error.response.status) { case 401: // 提示：登录过期，跳转登录页面重新登录  break; case 403: // 提示：权限不足  break; case 404: // 提示：资源不存在  break; default: // 提示：请求失败  break; } } return Promise.reject(error); } ); export function GET (url, payload) { return request.get(url, { params: payload }); } export function POST (url, payload) { return request.post(url, payload); } export function PUT (url, payload) { return request.put(url, payload); } export function PATCH (url, payload) { return request.patch(url, payload); } export function DELETE (url, payload) { return request.delete(url, { params: payload }); }   \r本文完，感谢阅读。😜\n","description":"","id":31,"section":"posts","tags":["ajax","axios"],"title":"Request Methods With Axios","uri":"https://webjam.cn/posts/2019/2019-11-22-request-methods-with-axios/"},{"content":" 没有 jquery 也可以愉快的操作类名了！\n classList 介绍 classList 是访问元素类的一种方便的方法。\n假设页面有这样一个元素：\n1  \u0026lt;div id=\u0026#34;box\u0026#34; class=\u0026#34;a b c\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   在 chrome 中打印它的 classList：\n1 2 3  var box = document.querySelector(\u0026#39;#box\u0026#39;) var classArray = box.classList console.log(classArray)   可以看到打印结果如下：\n可以看到 classList 是一个类数组的数据结构，每一项元素都是一个类名，length 是元素类名的个数。\nclassList 是只读属性，但是它提供了几个方法来修改类名：\n   方法 描述     add 添加一个或多个类名   contains 判断是否包含指定类名   items 返回索引对应的类名   remove 移除一个或多个类名   toggle 切换类名   replace 替换类名    ","description":"","id":32,"section":"posts","tags":["classList","html5"],"title":"Element ClassList Polyfill","uri":"https://webjam.cn/posts/2019/2019-11-20-element-classlist-polyfill/"},{"content":" 根据 moment.js 得到一个单位时间或者时间段（如本周，上周，本月，上月，当前季度，上个季度）的开始结束时间\n  momentjs 文档  主要利用以下几项 API：\n format(): 得到格式化的时间 startOf(): 得到一个单位时间的开始时间点，文档 endOf(): 得到一个单位时间的结束时间点 add(): 在指定时间点的基础上，加上一个时间段 subtract(): 在指定时间点的基础上，减去一个时间段 week(): 获取或设置一个时间对象的周数（第几周） month(): 获取或设置一个时间对象的月份 quarter(): 获取或设置一个时间对象的季度  天 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 获取当天开始结束时间 function getCurrDays () { let date = moment() let start = date.startOf(\u0026#39;days\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) let end = date.endOf(\u0026#39;days\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) return [ start, end ] } // 获取昨天的开始结束时间 function getYesterday () { let date = moment().subtract(\u0026#39;days\u0026#39;,1); let start = date.startOf(\u0026#39;days\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) let end = date.endOf(\u0026#39;days\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) return [ start, end ] } // 获取明天的开始结束时间 function getTomorrow () { let date = moment().add(\u0026#39;days\u0026#39;,1); let start = date.startOf(\u0026#39;days\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) let end = date.endOf(\u0026#39;days\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) return [ start, end ] }   周 获取某一周（本周，上周，下周）的开始结束时间，一周从周日开始到周六结束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 本周 function getCurrWeekDays () { let date = moment() let start = date.startOf(\u0026#39;week\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) let end = date.endOf(\u0026#39;week\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) return [ start, end ] } // 上一周 function getLastWeekDays () { let date = moment().week(moment().week() - 1) let start = date.startOf(\u0026#39;week\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) let end = date.endOf(\u0026#39;week\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) return [ start, end ] } // 下一周 function getNextWeekDays () { let date = moment().week(moment().week() + 1) let start = date.startOf(\u0026#39;week\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) let end = date.endOf(\u0026#39;week\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) return [ start, end ] }   月 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 本月 function getCurrMonthDays () { let date = moment() let start = date.startOf(\u0026#39;month\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) let end = date.endOf(\u0026#39;month\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) return [ start, end ]; } // 上个月 function getLastMonthDays () { let date = moment().month(moment().month() - 1) let start = date.startOf(\u0026#39;month\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) let end = date.endOf(\u0026#39;month\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) return [ start, end ]; } // 下个月 function getNextMonthDays () { let date = moment().month(moment().month() + 1) let start = date.startOf(\u0026#39;month\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) let end = date.endOf(\u0026#39;month\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) return [ start, end ]; }   季度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 当前季度 function getCurrQuarter () { let date = moment() let start = date.startOf(\u0026#39;quarter\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) let end = date.endOf(\u0026#39;quarter\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) return [ start, end ]; } // 上个季度 function getLastQuarter () { let date = moment().quarter(moment().quarter() - 1) let start = date.startOf(\u0026#39;quarter\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) let end = date.endOf(\u0026#39;quarter\u0026#39;).format(\u0026#39;YYYY-MM-DD\u0026#39;) return [ start, end ]; } // 下个季度 function getLastQuarter () { let date = moment().quarter(moment().quarter() + 1) }   DRY -  Don\u0026rsquo;t repeat yourself.\n 上面代码中可以看到有一个固定结构重复了好多次：\n1 2 3 4 5 6  function getX () { let date = x let start = date.startOf(\u0026#39;时间单位类型\u0026#39;).format(\u0026#39;格式化\u0026#39;) let end = date.endOf(\u0026#39;时间单位类型\u0026#39;).format(\u0026#39;格式化\u0026#39;) return [ start, end ]; }   所以我们可以专门封装一个函数，接收三个参数（时间，时间单位，格式化），返回开始和结束时间。\n1 2 3 4 5  function getDuringTime (date, type, format) { let start = date.startOf(type).format(format) let end = date.endOf(type).format(format) return [ start, end ]; }   有了此工具函数，将上面代码汇总如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  /** * @param {date} date [momentjs 时间对象] * @param {String} type [单位时间类型] * @param {String} format [时间格式] * type 可以接收的值： year, month, quarter, week, isoWeek, day, date, hour, minute, second */ function getDuringTime (date=moment(), type=\u0026#39;days\u0026#39;, format=\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) { let start = date.startOf(type).format(format) let end = date.endOf(type).format(format) return [ start, end ]; } // 获取当天开始结束时间 function getCurrDays () { let date = moment() return getDuringTime(date, \u0026#39;days\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 获取昨天的开始结束时间 function getYesterday () { let date = moment().subtract(\u0026#39;days\u0026#39;,1) return getDuringTime(date, \u0026#39;days\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 获取明天的开始结束时间 function getTomorrow () { let date = moment().add(\u0026#39;days\u0026#39;,1) return getDuringTime(date, \u0026#39;days\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 获取某一周（本周，上周，下周）的开始结束时间，一周从周日开始到周六结束。 // 本周 function getCurrWeekDays () { let date = moment() return getDuringTime(date, \u0026#39;week\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 上一周 function getLastWeekDays () { let date = moment().week(moment().week() - 1) return getDuringTime(date, \u0026#39;week\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 下一周 function getNextWeekDays () { let date = moment().week(moment().week() + 1) return getDuringTime(date, \u0026#39;week\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 本月 function getCurrMonthDays () { let date = moment() return getDuringTime(date, \u0026#39;month\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 上个月 function getLastMonthDays () { let date = moment().month(moment().month() - 1) return getDuringTime(date, \u0026#39;month\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 下个月 function getNextMonthDays () { let date = moment().month(moment().month() + 1) return getDuringTime(date, \u0026#39;month\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 当前季度 function getCurrQuarter () { let date = moment() return getDuringTime(date, \u0026#39;quarter\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 上个季度 function getLastQuarter () { let date = moment().quarter(moment().quarter() - 1) return getDuringTime(date, \u0026#39;quarter\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) } // 下个季度 function getLastQuarter () { let date = moment().quarter(moment().quarter() + 1) return getDuringTime(date, \u0026#39;quarter\u0026#39;, \u0026#39;YYYY-MM-DD\u0026#39;) }   本文完，感谢阅读。😜\n","description":"","id":33,"section":"posts","tags":["momentjs"],"title":"Get the Beginning and Ending in a Unit of Time via Momentjs","uri":"https://webjam.cn/posts/2019/2019-11-19-get-the-beginning-and-ending-in-a-unit-of-time-via-momentjs/"},{"content":"digraph G {\rsubgraph cluster_0 {\rstyle=filled;\rcolor=lightgrey;\rnode [style=filled,color=white];\ra0 -\u0026gt; a1 -\u0026gt; a2 -\u0026gt; a3;\rlabel = \u0026quot;process #1\u0026quot;;\r}\rsubgraph cluster_1 {\rnode [style=filled];\rb0 -\u0026gt; b1 -\u0026gt; b2 -\u0026gt; b3;\rlabel = \u0026quot;process #2\u0026quot;;\rcolor=blue\r}\rstart -\u0026gt; a0;\rstart -\u0026gt; b0;\ra1 -\u0026gt; b3;\rb2 -\u0026gt; a3;\ra3 -\u0026gt; a0;\ra3 -\u0026gt; end;\rb3 -\u0026gt; end;\rstart [shape=Mdiamond];\rend [shape=Msquare];\r}\r","description":"A hack to put Graphviz on the web.","id":34,"section":"posts","tags":[""],"title":"Viz support","uri":"https://webjam.cn/posts/test-viz/"},{"content":"{ \u0026quot;signal\u0026quot;: [ {\u0026quot;name\u0026quot;: \u0026quot;CLK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;p.....|...\u0026quot;},\r{\u0026quot;name\u0026quot;:\u0026quot;DAT\u0026quot;, \u0026quot;wave\u0026quot;:\u0026quot;x.345x|=.x\u0026quot;, \u0026quot;data\u0026quot;:[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;]},\r{\u0026quot;name\u0026quot;: \u0026quot;REQ\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;0.1..0|1.0\u0026quot;},\r{},\r{\u0026quot;name\u0026quot;: \u0026quot;ACK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;1.....|01.\u0026quot;}\r]}\r","description":"WaveDrom is a Free and Open Source online digital timing diagram (waveform) rendering engine that uses javascript, HTML5 and SVG to convert a WaveJSON input text description into SVG vector graphics.","id":35,"section":"posts","tags":[""],"title":"Wavedrom support","uri":"https://webjam.cn/posts/test-wavedrom/"},{"content":"{\r\u0026quot;type\u0026quot;: \u0026quot;bar\u0026quot;,\r\u0026quot;data\u0026quot;: {\r\u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;],\r\u0026quot;datasets\u0026quot;: [{\r\u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;,\r\u0026quot;data\u0026quot;: [12, 19, 3, 5, 3, 8]\r}]\r}\r}\r{\r\u0026quot;type\u0026quot;: \u0026quot;line\u0026quot;,\r\u0026quot;data\u0026quot;: {\r\u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;],\r\u0026quot;datasets\u0026quot;: [\r{\r\u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;,\r\u0026quot;data\u0026quot;: [12, 19, 3, 5, 2, 3],\r\u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;,\r\u0026quot;borderColor\u0026quot;:\u0026quot;orange\u0026quot;\r},\r{\r\u0026quot;label\u0026quot;: \u0026quot;Some other set\u0026quot;,\r\u0026quot;data\u0026quot;: [15, 8, 13, 5, 5, 9],\r\u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;,\r\u0026quot;borderColor\u0026quot;:\u0026quot;#44ccff\u0026quot;\r}\r]\r}\r}\r","description":"Simple yet flexible JavaScript charting for designers \u0026 developers","id":36,"section":"posts","tags":[""],"title":"Chart support","uri":"https://webjam.cn/posts/test-chartjs/"},{"content":"Alice-\u0026gt;Bob: Hello Bob, how are you?\rNote right of Bob: Bob thinks\rBob--\u0026gt;Alice: I am good thanks!\rTitle: Here is a title\rA-\u0026gt;B: Normal line\rB--\u0026gt;C: Dashed line\rC-\u0026gt;\u0026gt;D: Open arrow\rD--\u0026gt;\u0026gt;A: Dashed open arrow\r","description":"Generates UML sequence diagrams from simple text","id":37,"section":"posts","tags":[""],"title":"JS Sequence Diagram support","uri":"https://webjam.cn/posts/test-js-sequence-diagrams/"},{"content":"graph TD;\rA--\u0026gt;B;\rA--\u0026gt;C;\rB--\u0026gt;D;\rC--\u0026gt;D;\rsequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-\u0026gt;John: Hello John, how are you?\rloop Healthcheck\rJohn-\u0026gt;John: Fight against hypochondria\rend\rNote right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail...\rJohn--\u0026gt;Alice: Great!\rJohn-\u0026gt;Bob: How about you?\rBob--\u0026gt;John: Jolly good!\rgraph TD\rA[Hard] --\u0026gt;|Text| B(Round)\rB --\u0026gt; C{Decision}\rC --\u0026gt;|One| D[Result 1]\rC --\u0026gt;|Two| E[Result 2]\rgantt\rsection Section\rCompleted :done, des1, 2014-01-06,2014-01-08\rActive :active, des2, 2014-01-07, 3d\rParallel 1 : des3, after des1, 1d\rParallel 2 : des4, after des1, 1d\rParallel 3 : des5, after des3, 1d\rParallel 4 : des6, after des4, 1d\rclassDiagram\rClass01 \u0026lt;|-- AveryLongClass : Cool\r\u0026lt;\u0026lt;interface\u0026gt;\u0026gt; Class01\rClass09 --\u0026gt; C2 : Where am i?\rClass09 --* C3\rClass09 --|\u0026gt; Class07\rClass07 : equals()\rClass07 : Object[] elementData\rClass01 : size()\rClass01 : int chimp\rClass01 : int gorilla\rclass Class10 {\r\u0026lt;\u0026lt;service\u0026gt;\u0026gt;\rint id\rsize()\r}\rstateDiagram\r[*] --\u0026gt; Still\rStill --\u0026gt; [*]\rStill --\u0026gt; Moving\rMoving --\u0026gt; Still\rMoving --\u0026gt; Crash\rCrash --\u0026gt; [*]\rpie\r\u0026quot;Dogs\u0026quot; : 386\r\u0026quot;Cats\u0026quot; : 85\r\u0026quot;Rats\u0026quot; : 15 ","description":"Generate diagrams, charts, graphs or flows from markdown-like text via javascript.","id":38,"section":"posts","tags":["diagram"],"title":"Mermaid support","uri":"https://webjam.cn/posts/test-mermaid/"},{"content":" 使用 docker 快速安装 wordpress\n 卖瓜 这里卖瓜自夸一下我自己用的 docker-wordpress\n使用方法很简单：\n1 2 3 4 5  git clone https://github.com/wencaizhang/docker-wordpress cd docker-wordpress docker-compose up -d   ","description":"","id":39,"section":"posts","tags":["docker","wordpress"],"title":"Install Wordpress With Docker","uri":"https://webjam.cn/posts/2019/2019-11-17-install-wordpress-with-docker/"},{"content":" Ubuntu 基础设置，包含一些常用软件安装，配置文件修改等等。\n 这篇文章的意义在于，当你拿到一个新的 Ubuntu 系统之后，直接按照本文的步骤进行设置，就可以得到一个顺手的开发/部署环境。不再需要逐项搜索每个软件的安装步骤了。\n 设置国内软件镜像源 node git docker nginx oh-my-zsh alias vim  设置系统软件镜像源 配置系统源第一件事是修改镜像源，这样方便后续其他软件的安装。在国内可以选择阿里云的源。\n1 2 3 4 5 6  # 编辑源文件 sudo vim /etc/apt/sources.list # 在VIM编辑器内替换默认源为阿里云 :0,$ s/archive.ubuntu.com/mirrors.aliyun.com/ # 保存源文件并退出 :wq   包管理工具安装 先更新\n1  sudo apt update \u0026amp;\u0026amp; apt upgrade -y    Linux中apt与apt-get命令的区别与解释 linux命令系列 sudo apt-get update和upgrade的区别  安装常用软件\n通常会有一些是默认安装的，比如 git vim wget curl vim，如果没有，用下面方式安装即可。\n1  sudo apt install zsh nginx tree -y   oh-my-zsh 关于 zsh 和 oh-my-zsh 可以参考：终极 Shell——ZSH\n安装 脚本安装：\n1  wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh   或者手动安装:\n1 2  git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc   安装完成之后退出当前会话重新打开一个终端窗口即可。\n插件 (1) autojump\ngithub 地址 autojump\n下载并执行\n1 2  wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz ./install.sh   最后把以下代码加入.zshrc:\n1  [[ -s ~/.autojump/etc/profile.d/autojump.sh ]] \u0026amp;\u0026amp; . ~/.autojump/etc/profile.d/autojump.sh   node(nvm) nvm github 地址：nvm-sh/nvm\n方法一：脚本安装 执行脚本\n1 2 3  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash # 或者 wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash   最后，将下面内容分别添加到 ~/.bashrc, ~/.profile, 和 ~/.zshrc 文件中。\nexport NVM_DIR=\u0026quot;$([ -z \u0026quot;${XDG_CONFIG_HOME-}\u0026quot; ] \u0026amp;\u0026amp; printf %s \u0026quot;${HOME}/.nvm\u0026quot; || printf %s \u0026quot;${XDG_CONFIG_HOME}/nvm\u0026quot;)\u0026quot;\r[ -s \u0026quot;$NVM_DIR/nvm.sh\u0026quot; ] \u0026amp;\u0026amp; \\. \u0026quot;$NVM_DIR/nvm.sh\u0026quot; # This loads nvm\r加载配置文件：\n1  source ~/.bashrc   方法二：git 安装 将代码克隆到用户目录下：\n1 2  cd ~/ git clone https://github.com/nvm-sh/nvm.git .nvm   切换到最新版本\n1 2  cd ~/.nvm git checkout v0.35.1   激活 nvm，在命令行执行：\n1  . nvm.sh   最后，将下面内容分别添加到 ~/.bashrc, ~/.profile, 和 ~/.zshrc 文件中。\nexport NVM_DIR=\u0026quot;$HOME/.nvm\u0026quot;\r[ -s \u0026quot;$NVM_DIR/nvm.sh\u0026quot; ] \u0026amp;\u0026amp; \\. \u0026quot;$NVM_DIR/nvm.sh\u0026quot; # This loads nvm\r[ -s \u0026quot;$NVM_DIR/bash_completion\u0026quot; ] \u0026amp;\u0026amp; \\. \u0026quot;$NVM_DIR/bash_completion\u0026quot; # This loads nvm bash_completion\r完成之后，通过 nvm -v 查看版本来验证是否安装成功。\ndocker 安装 Docker 1  curl -fsSL https://get.docker.com -o get-docker.sh \u0026amp;\u0026amp; sudo sh get-docker.sh   安装 Compose 1 2 3 4 5 6 7  sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.22.0/docke-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose # 给Docker Compose 执行权限 sudo chmod +x /usr/local/bin/docker-compose #查看Docker和Docker Compose的版本 sudo docker version sudo docker-compose version   设置镜像源 执行下面命令进行设置\nps: 阿里云镜像源是个人注册阿里云账号之后分配的个人专属镜像源。\n1 2 3 4 5 6 7 8  sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://oojjt1xs.mirror.aliyuncs.com\u0026#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker   vim 配置 有些系统默认没有安装\n配置文件路径：\n 全局配置文件：/etc/vim/vimrc 当前用户配置文件：~/.vimrc  将下面内容粘贴到配置文件中：\n\u0026quot; 左单引号表示单行注释\r\u0026quot; 编码指定 UTF-8\rset fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936\rset termencoding=utf-8\rset encoding=utf-8\rset number \u0026quot; 显示行号\rset cursorline \u0026quot; 突出显示当前行\rset ruler \u0026quot; 打开状态栏标尺\r设置别名(alias) 将所有的别名放在单独一个文件 .bash_aliases 中，这样更加方便管理，ubuntu 也推荐这种做法。\n1 2 3  if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi   注意：等号两侧不能有空格!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 代替键盘上难以触及的 ~ 键 alias home=\u0026#34;cd ~\u0026#34; # 同样也可以为一些深层却很常用的目录设置别名 # 如：宝塔面包的 nginx 配置目录 alias ng=\u0026#34;cd /www/server/panel/vhost/nginx\u0026#34; # 回退多级目录 alias bk1=\u0026#34;cd ..\u0026#34; alias bk2=\u0026#34;cd ../..\u0026#34; alias bk3=\u0026#34;cd ../../..\u0026#34; alias bk4=\u0026#34;cd ../../../..\u0026#34; alias bk5=\u0026#34;cd ../../../../..\u0026#34; # ls 相关 alias cls=\u0026#39;clear\u0026#39; alias ll=\u0026#39;ls -l\u0026#39; alias la=\u0026#39;ls -a\u0026#39; # git 相关 alias gs=\u0026#39;git status\u0026#39; alias glog=\u0026#34;git log --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Cr eset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; # 解压 alias -s gz=\u0026#39;tar -xzvf\u0026#39; alias -s tgz=\u0026#39;tar -xzvf\u0026#39; alias -s zip=\u0026#39;unzip\u0026#39; alias -s bz2=\u0026#39;tar -xjvf\u0026#39; # other alias vi=\u0026#39;vim\u0026#39; alias grep=\u0026#34;grep --color=auto\u0026#34; alias tree=\u0026#34;tree -I \u0026#39;*svn|*node_module*\u0026#39;\u0026#34;   本文完，感谢阅读。😜\n","description":"","id":40,"section":"posts","tags":["ubuntu"],"title":"Basic Setup for Ubuntu","uri":"https://webjam.cn/posts/2019/2019-11-17-basic-setup-for-ubuntu/"},{"content":"使用脚本快速安装 安装 Docker:\n1  curl -fsSL https://get.docker.com -o get-docker.sh \u0026amp;\u0026amp; sudo sh get-docker.sh   安装 docker-compose\n1 2 3 4 5 6 7 8 9  sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)\u0026#34; \\ -o /usr/local/bin/docker-compose # 给Docker Compose 执行权限 sudo chmod +x /usr/local/bin/docker-compose # 查看Docker和Docker Compose的版本 sudo docker version sudo docker-compose version   设置阿里云镜像 1 2 3 4 5 6 7 8  sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://oojjt1xs.mirror.aliyuncs.com\u0026#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker   阿里云镜像源需要个人注册阿里云账号之后才能使用，这里我已经注册过了。\n三个概念  Docker三个基本概念：Registry注册中心，Image镜像，Container容器\n   Registry包含多个Repo（仓库）和Tag(标签)，从Registry下载Image的方式是pull \u0026lt;仓库名\u0026gt;:\u0026lt;标签名\u0026gt;，如pull ubuntu:16.04     Image是一个静态概念，相当于面向对象中的类，类不能直接使用，需要实例化。     Container是一个动态概念，相当于面向对象中的实例化，启动镜像生成容器就是实例化类的过程。只有容器才能被用户使用。   查看命令    命令 描述     docker images 列出本地镜像   docker ps 列出容器    创建容器   创建一个新的容器，并进入交互模式的终端\n1  docker run -it centos:latest /bin/bash     后台运行容器，并设置端口映射\n1  docker run -d -p 3000:80 centos:latest     进入一个正在后台运行的容器\n1  docker attach [container-id]     退出容器   退出容器\n1  exit     退出容器并保持容器后台运行\nCtrl + p + q\r  从容器创建新的镜像   首先拿到容器 ID ，然后使用如下命令创建镜像：\n1  docker commit -a \u0026#34;镜像作者名字\u0026#34; -m \u0026#34;提交时的说明文字\u0026#34; [container-id] [image-name]:[tag]     WordPress 启动方式   创建容器\n1  docker run -it -p 3000:80 -p 4000:8888 my_wp:v1 /bin/bash     软件启动\n1 2 3 4 5 6 7 8 9  /etc/init.d/nginx start /etc/init.d/mysqld start /etc/init.d/memcached start /etc/init.d/php-fpm-72 start /etc/init.d/bt start     退出容器，并保持容器在后台运行\n1  Ctrl + p + q     相关文档  Docker命令大全 - 菜鸟教程 daocloud 镜像站 Docker — 从入门到实践(语雀)  ","description":"","id":41,"section":"posts","tags":["docker"],"title":"Basic Usage of Docker","uri":"https://webjam.cn/posts/2019/2019-11-16-basic-usage-of-docker/"},{"content":"安装 1 2  # ubuntu sudo apt install nginx -y   命令 nginx 命令    描述 命令 命令二     启动 sudo nginx sudo /usr/sbin/nginx   停止 sudo nginx -s stop sudo /usr/sbin/nginx -s stop   重启 sudo nginx -s restart sudo /usr/sbin/nginx -s restart   重载配置文件 sudo nginx -s reload sudo /usr/sbin/nginx -s reload    nginx 目录    描述 命令     nginx 安装目录 /usr/sbin/nginx   默认网站根目录 /usr/share/nginx/html   配置文件 /etc/nginx/nginx.conf     查找 nginx 安装目录的命令    描述 命令     查找 nginx 安装目录 which nginx   查找 nginx 配置文件 sudo find / -name nginx.conf   检测配置文件语法是否正确： sudo /usr/sbin/nginx -t    常见使用场景 (一) 静态网站 指定域名和对应的网站根目录位置，server_name 可以是域名、二级域名，也可以是 ip 地址。\nserver {\rlisten 80;\rserver_name demo.example.com;\rlocation / {\rroot /www/demo/;\rindex index.html index.htm;\r}\r}\r(二) 反向代理 场景：\n 解决跨域问题，利用 nginx 来访问其他域名下的接口 当 docker 服务的端口映射到宿主机上某个端口（如 8080）时，可以设置二级域名代理 8080 端口。  server {\rserver_name docker.example.com;\rlisten 80;\rlocation / {\rproxy_pass http://localhost:8000;\rproxy_set_header Host $host;\rproxy_set_header X-Forward-For $remote_addr;\r}\r}\r(三) 负载均衡 upstream backend {\rserver backend1.example.com weight=5;\rserver backend2.example.com:8080;\rserver unix:/tmp/backend3;\r}\rserver {\rlocation / {\rproxy_pass http://backend;\r}\r}\r一些学习资源 Nginx中文文档\n","description":"","id":42,"section":"posts","tags":["nginx"],"title":"Basic Usage of Nginx","uri":"https://webjam.cn/posts/2019/2019-11-16-basic-usage-of-nginx/"},{"content":"Traefik 初体验 Traefik 是什么？\n Træfɪk 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具。 它支持多种后台 (Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd, Zookeeper, BoltDB, Rest API, file…) 来自动化、动态的应用它的配置文件设置。\n 简而言之，traefik 是一个可以替代 nginx 的 web 服务器，它的好处有很多，其中最吸引我的有两点：\n 自动生成 HTTPS 证书（Let\u0026rsquo;s Encrypt） 自动发现服务（Auto Service Discovery），可以和 Docker 更好的结合  下面就来体验一下 traefik 吧。\n安装 traefik traefik 支持二进制文件、docker镜像、手动编译三种安装方式，这里我选择的是 docker 镜像安装。\n新建一个 traefik 目录，然后创建一个 docker-compose.yml 文件，使用 traefik 官方镜像定义一个名为 reverse-proxy 的服务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  version:\u0026#39;3\u0026#39;services:reverse-proxy:# 官方镜像 2.0image:traefik:v2.0# Enables the web UI and tells Traefik to listen to dockercommand:- \u0026#34;--api.insecure=true\u0026#34;- \u0026#34;--providers.docker\u0026#34;ports:- \u0026#34;80:80\u0026#34;- \u0026#34;8080:8080\u0026#34;volumes:- /var/run/docker.sock:/var/run/docker.sock  然后通过下面命令启动 reverse-proxy 服务：\n1  sudo docker-compose up -d reverse-proxy   此时可以通过 IP + 8080 端口访问到 traefik 提供的 dashboard。\n这里有一些细节需要注意：\n 启用 traefik 的 API 功能，使 traefik 向外暴露一些诸如路由、服务、中间件之类的信息（默认是 8080 端口）。  1 2 3 4  command:- \u0026#34;--api.insecure=true\u0026#34;ports:- \u0026#34;8080:8080\u0026#34;   通知 traefik 去监听 docker 的事件流  1 2  command:- \u0026#34;--providers.docker\u0026#34;   挂载 /var/run/docker.sock，用于监听 docker 事件流  1 2  volumes:- /var/run/docker.sock:/var/run/docker.sock  自动发现服务 上面 reverse-proxy 服务\n以 whoami 服务为例，whoami 是一个查看主机信息的服务，镜像大小只有 7M 左右，非常适合用于测试。\n新建目录 whoami，并创建 docker-compose.yml 文件，文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  version:\u0026#34;3.3\u0026#34;services:whoami:image:\u0026#34;containous/whoami\u0026#34;labels:- \u0026#34;traefik.enable=true\u0026#34;# 指定 whoami 服务的域名- \u0026#34;traefik.http.routers.whoami.rule=Host(`whoami.wencaizhang.com`)\u0026#34;- \u0026#34;traefik.http.routers.whoami.entrypoints=web\u0026#34;networks:- traefiknetnetworks:traefiknet:external:true  在 whoami 目录下启动服务：\n1  sudo docker-compose up -d whoami   前面已经提到 reverse-proxy 能够监听到 docker 事件流，所以当 whoami 服务启动之后，可以直接访问 whoami.wencaizhang.com，来查看 whoami 服务输出的相关信息了。\n创建 Docker 网络\n1  docker network create -d bridge traefik-net   ","description":"","id":43,"section":"posts","tags":["traefik","docker"],"title":"Basic Usage of Traefik","uri":"https://webjam.cn/posts/2019/2019-11-16-basic-usage-of-traefik/"},{"content":"When $a \\ne 0$, there are two solutions to $(ax^2 + bx + c = 0)$ and they are\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$\n","description":"A JavaScript display engine for mathematics that works in all browsers.No more setup for readers. It just works.","id":44,"section":"posts","tags":[""],"title":"MathJax support","uri":"https://webjam.cn/posts/test-mathjax/"},{"content":"GitHub’s search supports a variety of different operations. Here’s a quick cheat sheet for some of the common searches.\nFor more information, visit our search help section.\n基本搜索 \r\r\r示例\r描述\r\r\r\r\rcat stars:\u0026gt;100\r搜索和 cat 相关的且超过 100 star 的仓库.\r\r\ruser:defunkt\r找到 defunkt 用户下的所有仓库\r\r\rtom location:\"San Francisco, CA\"\r找到所有位于 “San Francisco, CA” 且和 tom 相关的用户\r\r\rjoin extension:coffee\rFind all instances of join in code with coffee extension.\r\r\rNOT cat\r排除所有包含 cat 的结果\r\r\r\r搜索代码仓库 Repository search looks through the projects you have access to on GitHub. You can also filter the results:\n你可以添加过滤条件：\n\r\r\r示例\r描述\r\r\r\r\rpugs pushed:\u0026gt;2013-01-28\rPugs 相关的仓库且最新代码提交时间在 2013-01-28 之后\r\r\rnode.js forks:\u0026lt;200\r所有 node.js 相关仓库且少于 200 forks.\r\r\rjquery size:1024..4089\r代码库的大小在 1024 和 4089 kB 之间的 jquery 相关仓库\r\r\rgitx fork:true\rRepository search includes forks of gitx.\r\r\rgitx fork:only\rRepository search returns only forks of gitx.\r\r\r\r搜索代码 Code search looks through the files hosted on GitHub. You can also filter the results:\n\r\r\r示例\r描述\r\r\r\r\rinstall repo:charles/privaterepo\rFind all instances of install in code from the repository charles/privaterepo.\r\r\rshogun user:heroku\rFind references to shogun from all public heroku repositories.\r\r\rjoin extension:coffee\rFind all instances of join in code with coffee extension.\r\r\rsystem size:\u0026gt;1000\rFind all instances of system in code of file size greater than 1000kbs.\r\r\rexamples path:/docs/\rFind all examples in the path /docs/.\r\r\rreplace fork:true\rSearch replace in the source code of forks.\r\r\r\r搜索 Issue Issue search looks through issues and pull requests on GitHub. You can also filter the results:\n\r\r\r示例\rFinds issues…\r\r\r\r\rencoding user:heroku\rEncoding issues across the Heroku organization.\r\r\rcat is:open\rFind cat issues that are open.\r\r\rstrange comments:\u0026gt;42\rIssues with more than 42 comments.\r\r\rhard label:bug\rHard issues labeled as a bug.\r\r\rauthor:mojombo\rAll issues authored by mojombo.\r\r\rmentions:tpope\rAll issues mentioning tpope.\r\r\rassignee:rtomayko\rAll issues assigned to rtomayko.\r\r\rexception created:\u0026gt;2012-12-31\rCreated since the beginning of 2013.\r\r\rexception updated:\u0026lt;2013-01-01\rLast updated before 2013.\r\r\r\r搜索用户 User search finds users with an account on GitHub. You can also filter the results:\n\r\r\r示例\r描述\r\r\r\r\rfullname:\"Linus Torvalds\"\rFind users with the full name \"Linus Torvalds\".\r\r\rtom location:\"San Francisco, CA\"\rFind all tom users in \"San Francisco, CA\".\r\r\rchris followers:100..200\r找到 chris 相关的用户，并且 followers 数量在 100 到 200 之间\r\r\rryan repos:\u0026gt;10\r用户名和 ryan 相关的，且拥有超过 10 个仓库的用户\r\r\r\r相关链接   github 搜索页面\n  github 可视化高级搜索页面\n  github 搜索功能介绍\n  ","description":"","id":45,"section":"posts","tags":["github","search"],"title":"Github 搜索规则备忘单","uri":"https://webjam.cn/posts/2019/2019-11-15-github-search-cheat-sheet/"},{"content":"The following\n$$ \\int_{a}^{b} x^2 dx $$\nIs an integral\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nEnable Katex in the config file by setting the katex param to true. This will import the necessary Katex CSS/JS.\nSee the online reference of supported TeX functions.\nNote: For inline math to render correctly, your content file extension must be .mmark. See the official mmark site.\nInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\rInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\nBlock math:\r$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\rBlock math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","description":"KaTeX is a fast, easy-to-use JavaScript library for TeX math rendering on the web.","id":46,"section":"posts","tags":[""],"title":"Katex support","uri":"https://webjam.cn/posts/test-katex/"},{"content":"st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank]\re=\u0026gt;end: End|future:\u0026gt;http://www.google.com\rop1=\u0026gt;operation: My Operation|past\rop2=\u0026gt;operation: Stuff|current\rsub1=\u0026gt;subroutine: My Subroutine|invalid\rcond=\u0026gt;condition: Yes\ror No?|approved:\u0026gt;http://www.google.com\rc2=\u0026gt;condition: Good idea|rejected\rio=\u0026gt;inputoutput: catch something...|future\rst-\u0026gt;op1(right)-\u0026gt;cond\rcond(yes, right)-\u0026gt;c2\rcond(no)-\u0026gt;sub1(left)-\u0026gt;op1\rc2(yes)-\u0026gt;io-\u0026gt;e\rc2(no)-\u0026gt;op2-\u0026gt;e\r","description":"flowchart.js is a flowchart DSL and SVG render that runs in the browser and terminal. Nodes and connections are defined in separately so that nodes can be reused and connections can be quickly changed.","id":47,"section":"posts","tags":[""],"title":"Flowchart support","uri":"https://webjam.cn/posts/test-flowchart/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":48,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://webjam.cn/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":49,"section":"gallery","tags":null,"title":"Photo","uri":"https://webjam.cn/gallery/photo/"},{"content":"get started at the end of this tutorial you will create a vuepress blog that looks and feels like this demo http://vp-modern.z3by.com,\nYou can scaffold your project how ever you want, here we will use Create Vuepress with the Blog boilerplate.\nso let\u0026rsquo;s get started by running this command in an empty directory\n1  yarn create vuepress   Now you will be prompted to choose what boilerplate you want to go with, let\u0026rsquo;s select blog\nAfter that you will be prompted for some basic info.\nthen, let\u0026rsquo;s open the project with a good code editor (Visual Studio Code 😉)\nThe directory structure will look like this\nall posts will go inside /blog/_posts/\nlet\u0026rsquo;s install dependencies and run a development serve by running\n1  yarn \u0026amp;\u0026amp; yarn dev   you can access the development server at http://localhost:8080/\nInstall My theme Let\u0026rsquo;s install my theme by running\n1  yarn add -D vuepress-theme-modern-blog   Then let\u0026rsquo;s change Vuepress config,\nopen /blog/.vuepress/config.js then change theme value from\n1  theme: \u0026#39;@vuepress/theme-blog\u0026#39;,   to\n1  theme: \u0026#39;modern-blog\u0026#39;,   you might need to restart the development server.\nAdd Frontmatter metadata to the posts Let\u0026rsquo;s take one of the demo posts generated by the first step and let\u0026rsquo;s add some new Frontmatter metadata into it.\nCurrent metadata is on the upper section of the post that is located withing --- mark,\nlike this\n1 2 3 4 5 6 7 8  ---date:2018-11-7tag:- frontmatter- vuepressauthor:ULIVZlocation:Hangzhou---  We can add some values that will improve how the post looks, for example we can specify title, description and Image.\n1 2 3 4 5 6 7 8 9 10 11  ---date:2018-11-7tag:- frontmatter- vuepressauthor:ULIVZlocation:Hangzhoutitle:FrontMatterinVuePressdescription:WhatisFrontMatterinVuepress🤔🤔🤔image:https://static.qdskill.com/2018/05/vuepress.jpg---  Now you can see the difference\nNOTE to use internal image link you can put your image inside the public directory in .vuepress/public/images then the image value will be like this\n1  image:/images/\u0026lt;YOUR_IMAGE_HERE\u0026gt;  Increase Posts per page now the current config shows only 2 Posts per page, to increase this number we will modify blog plugin options by modifying this method in /blog/.vuepress/config.js\n1 2 3 4  // path: /blog/.vuepress/config.js  modifyBlogPluginOptions(blogPluginOptions) { return blogPluginOptions },   we will modify it to be\n1 2 3 4 5 6  modifyBlogPluginOptions(blogPluginOptions) { blogPluginOptions[\u0026#34;directories\u0026#34;].find( el =\u0026gt; el.id == \u0026#34;post\u0026#34; ).pagination.lengthPerPage = 10; return blogPluginOptions; },   it is not a magic you can check this to see what we have done here.\nCustomize Theme Change theme Colors to change theme colors let\u0026rsquo;s navigate to blog/.vuepress/styles/palette.styl\nyou can see that it contains some Stylus variables, let\u0026rsquo;s change the $accentColor to #6A82FB\nand let\u0026rsquo;s add a new variable and let\u0026rsquo;s name it $secondaryColor and give it a value of #FC5C7D\n🎉 Now you can see that the whole theme colors did change\nadd custom styling now you can see that te footer colors looks ugly! I did this on purpose 😈 to let you add your own styling and not to stick to mine!\nto change Footer style you can inspect the page using your browser and check the proper css selector for the element you want to change, in our case it is a \u0026lt;footer\u0026gt; element with a class attribute set to footer\nso let\u0026rsquo;s go to .vuepress/styles/index.styl and let\u0026rsquo;s add some styling for example\nfooter.footer\rbackground lighten(#000, 20%) !important\ryou might need !important statement in some cases not all cases, but it is a good practice to use it wisely.\nChange Hero Image this theme is using Unsplash Random API as a place holder for the Hero Image, to replace it with your own image just add your image to themeConfig like this\n1 2 3  themeConfig: { heroImage: \u0026#34;\u0026lt;YOUR_NEW_IMAGE_URL\u0026gt;\u0026#34;, ...   Add commenting functionality We will use Disqus as a commenting engine, so go ahead and create an account, and get the Short Website Name from Disqus configurations, put it inside themeConfig object in .vuepress/config.js as follows\n1 2 3  themeConfig: { disqus: \u0026#34;\u0026lt;DISQUS WEBSITE SHORT NAME\u0026gt;\u0026#34;, ...   now you will see this cool comments box after each post\nAdd google analytics after deploying your Blog you will need to know some statistics about your website, how much visitors you have and where your website visits are coming from, etc\u0026hellip;\nto have these cool features we will incorporate Google Analytics, to get started you just need to create an account on Google analytics, then you need to create a property that is linked to your domain, after that you can get the Tracking ID of this property, it is usually composed of some numbers, prefixed with UA-\ncopy this value and add it to themeConfig this way:\n1 2 3  themeConfig: { googleAnalytics: \u0026#34;UA-************\u0026#34;, // replace this value with your tracking ID  ...   Add Sitemap Sitemaps are very important for your website to be indexed by google, you can learn more about Sitemaps here\nWe will auto generate a sitemap for our blog, all you need to do is to add these two settings to you themeConfig\n1 2 3 4  themeConfig: { sitemap: true, hostname: \u0026#34;https://www.yourdomain.com/\u0026#34;, ...   replace hostname value with your own domain name, for example mine is https://www.ahmadmostafa.com/\nAdd Social-Sharing feature It is good to allow your users to share your posts on their Social Media accounts, Disqus already offers this feature, but it is good to make it more visible to your users so you encourage them to share your content, we will add these settings to themeConfig to enable social sharing feature\n1 2 3 4  themeConfig: { socialShare: true, socialShareNetworks: [\u0026#34;twitter\u0026#34;, \u0026#34;facebook\u0026#34;], ...   you can add other networks to socialShareNetworks array.\nnow you can see a cool floating button on the right side of your posts that help your users sharing your content! 🎉\nThat\u0026rsquo;s It! 🎉\ngo and add some cool posts! 😉\n","description":"Create a modern vuepress blog in 5 minutes!","id":54,"section":"posts","tags":["blog","python"],"title":"Create a modern vuepress blog in 5 minutes!","uri":"https://webjam.cn/posts/vuepress-modern-blog-theme/"},{"content":"JavaScript 中的 this 总是指向一个对象，而具体指向哪个对象是在函数运行时的环境动态绑定的，而非函数被声明时的环境。\n但是 ES6 标准新增的箭头函数中的 this 却是由被声明的环境即上下文来确定的。\n因此 this 的场景大致分为下面 5 种：\n 作为对象的方法调用 作为普通函数调用 作为构造器调用 通过 call 和 apply 调用 箭头函数  情况一：作为普通函数调用 当函数作为普通函数或者匿名函数调用时，this 总是指向全局对象，在浏览器中这个全局对象是 window，在 nodejs 中全局对象是 global，这里讨论的是浏览器端，所有代码都可以在 chrome 开发者工具的 console 面板中执行。\nES5 规范提出了「严格模式」，在整个脚本文件第一行或者函数内第一行添加一条语句 'use strict'; 即可开启严格模式。\n如果启用「严格模式」，那么 this 就不再是指向全局对象，而是 undefined 。\n1) 普通函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13  window.name = \u0026#39;global name\u0026#39;; function printName1 () { console.log(this === window); // true  console.log(this.name); // \u0026#34;global object\u0026#34; } function printName2 () { \u0026#34;use strict\u0026#34;; // 启用严格模式  console.log(this); // undefined } printName1(); printName2();   2) 匿名函数：\n匿名函数自执行，这种形式封装公用库的时候最常见：\n1 2 3 4 5  window.name = \u0026#39;global name\u0026#39;; (function () { console.log(this === window); // true  console.log(this.name); // \u0026#34;global object\u0026#34; })()   作为参数的匿名函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13  window.name = \u0026#39;global name\u0026#39;; setTimeout(function () { console.log(this === window); // true  console.log(this.name); // \u0026#34;global object\u0026#34; }, 100); [1, 2, 3].forEach(function (item) { console.log(item, this.name) // 1 \u0026#34;global name\u0026#34;  // 2 \u0026#34;global name\u0026#34;  // 3 \u0026#34;global name\u0026#34; });   情况二：作为对象的方法调用 当函数作为对象当属性方法调用时，this 总指向这个对象。\n1 2 3 4 5 6 7 8 9  var obj = { name: \u0026#39;obj\u0026#39;, printName: function () { console.log(this === obj); // true  console.log(this.name); // \u0026#34;obj\u0026#34;  } } obj.printName();   但是如果一个对象的属性方法又赋值给了其他变量，那么 this 将发生变化，其指向只有在函数执行那一刻才能确定。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var obj = { name: \u0026#39;obj\u0026#39;, printName: function () { console.log(this === obj); // true  console.log(this.name); // \u0026#34;obj\u0026#34;  } } var myPrintName = obj.printName; window.name = \u0026#39;global name\u0026#39;; myPrintName(); // false // \u0026#34;global name\u0026#34;   当 myPrintName 执行时，就要按照普通函数来判断 this 指向了。\n再来一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var obj = { name: \u0026#39;obj\u0026#39;, printName: function () { console.log(this === obj); // true  console.log(this.name); // \u0026#34;obj\u0026#34;  } } var obj2 = { name: \u0026#39;obj2\u0026#39;, } obj2.printName = obj.printName; obj2.printName(); // false // \u0026#34;obj2\u0026#34;   当 obj2.printName 执行时，printName 是作为 obj2 的属性方法来调用的，因此 this 指向 obj2 这个对象。\n所以说，JavaScript 中的 this 指向无法在定义时判断，只有在其执行时才能判断。\n情况三：作为构造器调用 在 JavaScript 中没有「类」的概念（直到 ES6 才有类的出现），而是把函数作为构造器，通过 new 操作符来生成实例。\n那么在构造函数中 this 就指向新生成的实例。\n1 2 3 4 5 6 7 8 9  var MyClass = function () { // 给实例添加 name 属性  this.name = \u0026#39;myclass\u0026#39; this.printName = function () { return this.name } } var obj = new MyClass() obj.printName() // \u0026#34;myclass\u0026#34;   情况四：显式指定 this 前面的几种方法都是被动地根据代码执行时的环境来判断 this 具体指向哪里，那么有没有办法主动指定 this 指向呢。\n答案当然是有的，甚至它们的出场率还相当高。\n常见的显式指定 this 的方法主要是 call，apply 和 bind 来，在函数式编程中几乎离不开这三个方法。\n先定义如下变量：\n1 2 3 4 5 6 7 8  window.name = \u0026#39;global name\u0026#39; function printName () { console.log(this.name) } var obj1 = { name: \u0026#39;obj1\u0026#39; } var obj2 = { name: \u0026#39;obj2\u0026#39; } var obj3 = { name: \u0026#39;obj3\u0026#39; }   默认情况 this 指向全局对象 window\n1  printName() // \u0026#34;global name\u0026#34;   使用 call 来改变 this 指向：\n1  printName.call(obj1) // \u0026#34;obj1\u0026#34;   使用 apply 来改变 this 指向：\n1  printName.apply(obj2) // \u0026#34;obj2\u0026#34;   使用 bind 来改变 this 指向：\n1 2  var printName2 = printName.bind(obj3) printName2() // \u0026#34;obj3\u0026#34;   除此之外，还有一些函数也可以修改 this 指向，例如：forEach, map, filter, some, every 等。以 forEach 为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var obj = { name: \u0026#39;zwc\u0026#39; } var arr = [ 1, 2 ] arr.forEach(function (item, index) { console.log(item, this) }) // 1 Window // 2 Window  arr.forEach(function (item, index) { console.log(item, this) }, obj) // 1 {name: \u0026#34;zwc\u0026#34;} // 2 {name: \u0026#34;zwc\u0026#34;}   forEach 第一个参数接收一个函数作为迭代器，用来处理数组中每一项元素，这个函数通常是一个匿名函数，函数内部的 this 指向全局对象。\nforEach 第二个参数可以接收一个对象，这个对象就是参数函数中的 this 指向。\n根据打印结果可以看到，在 forEach 的迭代器函数中的 this 已经指向了 obj 。\n情况五：ES6箭头函数 箭头函数简介 ES6 允许使用「箭头」（=\u0026gt;）定义函数。\n1 2 3 4 5 6  var f = v =\u0026gt; v; // 等同于 var f = function (v) { return v; };   除了形式更简洁之外，箭头函数没有自己的 this，而是从自己作用域链的上一层继承 this。\n 箭头函数总是从自己作用域链的上一层继承 this。\n 神马意思呢？我的理解就是箭头函数内部的 this 指向永远是箭头函数被定义时所在的作用域的 this，并且无法修改。\n无法绑定 this 使用 call 来调用箭头函数时，第一个参数会被忽略，也就是说无法修改 this 指向。apply 和 bind 也是同样现象。\n1 2 3 4 5 6 7  var printName = () =\u0026gt; { console.log(this === window); // true } var obj = { name: \u0026#39;obj\u0026#39; } printName.call(obj);   例子一 来看一个例子，在不使用箭头函数的情况下，我们知道构造器函数内部 this 指向对象实例，而匿名函数的 this 是指向全局对象的，因此想要通过定时器打印对象实例的 age 属性，只能用一个变量 self 保存 this 的引用（即闭包）\n1 2 3 4 5 6 7 8 9 10 11  function Person(){ // 构造器函数内部 this 指向对象实例  this.age = 0; var self = this; setInterval(function () { // 匿名函数中 this 指向全局对象  console.log(self.age++) }, 1000); } var p = new Person();   使用箭头函数之后，因为箭头函数的 this 继承自其被定义时所在环境的 this，在本例中这个 this 就是实例对象：\n1 2 3 4 5 6 7 8 9 10  function Person(){ // 构造器函数内部 this 指向对象实例  this.age = 0; setInterval(() =\u0026gt; { // 这里的 this 也指向构造函数的 this  console.log(this.age++) }, 1000); } var p = new Person();   例子二 再说一个更实用的例子：在 Vue.js 中使用箭头函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import axios from \u0026#39;axios\u0026#39;; export default { methods: { fetch () { axios.get(\u0026#39;/userinfo\u0026#39;) .then(resp =\u0026gt; { this.sayHi(); // this 指向 vue 实例  }) .catch(err =\u0026gt; { this.sayHi(); // this 指向 vue 实例  }) }, sayHi () { setTimeout(() =\u0026gt; { // this 指向 vue 实例  }, 1000); } } }   使用箭头函数之后，再也无需缓存 vue 实例，像是 var vm = this; 这种代码统统可以消灭掉，嗯，清爽！\n相关链接   严格模式 - MDN\n  箭头函数 - MDN\n  箭头函数 - ES6 入门\n  总结 在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值：\n 如果是该函数是一个普通函数或者匿名函数  在严格模式下的函数调用下，this 指向 undefined， 在非严格模式的函数调用中，this 指向全局对象，浏览器中全局对象是 window ，在 nodejs 中全局对象是 global   如果是该函数是一个构造函数，this 指针指向一个新的对象（实例） 如果是该函数是一个对象的方法，则它的this 指针指向这个对象 或者使用 call apply 等方法显式指定 this 的指向  在箭头函数中，则是根据箭头函数上下文决定其 this 指向，且无法修改 this 指向。\n本文完，感谢阅读。😜\n","description":"","id":55,"section":"posts","tags":["js","this指向"],"title":"JavaScript 中 this 总结","uri":"https://webjam.cn/posts/2019/2019-09-29-this-in-javascript/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":56,"section":"","tags":null,"title":"About","uri":"https://webjam.cn/about/"},{"content":"js 中使用 let 和 const 的总结 ES6 引入了 let 命令用于声明变量，引入了 const 命令用于声明常量。然而仅仅知道这些是不够的，具体哪些场景下使用 let，哪些场景使用 const 仍然令人感到疑惑。\n这两个命令的学习可参考文章：let 和 const 命令，这里只参考下面一段话：\n const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。\n 因此，我认为声明简单类型数据（数字、字符串、布尔值）的时候使用 let，而在声明引用类型（对象、数组）的时候使用 const。\n参考  let 和 const 命令 js中 let var const 的差异和使用场景  ","description":"","id":57,"section":"posts","tags":null,"title":"js 中使用 let 和 const 的总结","uri":"https://webjam.cn/posts/2019/difference-of-let-and-const/"},{"content":"「译」从 URL 输入到页面展现发生了什么  本文翻译自：What really happens when you navigate to a URL\n为方便理解，本文采用意译，如有兴趣，可阅读英文原文\n 步骤：  在浏览器中输入网址 浏览器查找域名对应的 IP 地址 浏览器向服务器发送 HTTP 请求 服务器响应并进行重定向 浏览器向真正的服务器重新发送 HTTP 请求 服务器处理 HTTP 请求 服务器响应请求，返回 HTML 页面 浏览器渲染 HTML 页面 浏览器请求静态资源，如 css 文件、图片、js 文件 浏览器发送异步请求  作为软件开发者，你肯定对 web 应用如何工作以及它工作过程中包含的技术（浏览器、HTML、web server、request handlers 等等）都有一个高水平的认知。\n这篇文章中，我们会对当你访问一个 URL 时发生的一系列事情进行深入研究。\n1. 在浏览器中输入网址 输入网址 facebook.com，故事从这里开始：\n2. 浏览器查找域名对应的 IP 地址 访问一个 URL 的第一步就是得到域名对应的 IP 地址，DNS（Domain Name System，域名系统，万维网上作为域名和IP地址相互映射的一个分布式数据库）查找顺序如下：\n 浏览器缓存（Browser cache） 系统缓存（OS cache） 路由器缓存（Router cache） ISP DNS 缓存（ISP DNS cache） 递归查找（Recursive search）  这里有一个图来描述 DNS 递归查找的过程\n 关于 DNS 有件值得担心的事是整个域名像是 wikipedia.org 或者 facebook.com 看起来像是仅仅映射到单一的一个 IP 地址。幸运的是，这里有一些缓解瓶颈的方法：\n Round-robin DNS(轮询调度 DNS)是 DNS 查询结果为多个 IP 地址而不是仅仅一个 IP 地址的解决方案。例如它就解决了 facebook.com 实际上对应着四个 IP 地址的问题。 Load-balancer (负载均衡)是通过硬件监听指定 IP 地址并且将请求转发到其他服务器。大型网站是使用昂贵的高性能负载均衡器的典型例子。 Geographic DNS (地理域名系统)通过映射一个域名到不同的 IP 地址的方式提升了可扩展性，这种方法依赖于客户端的地理位置。 Anycast (任播)是将一个 IP 地址映射到多个物理服务器的路由技术。不幸的是，任播并不适合 TCP 协议，因此在这种情况下几乎不会使用它。    绝大部分 DNS 服务器本身使用任播协议来实现 DNS 的高可用性和低延迟性。\n任播(anycast): 是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。\n 3. 浏览器向服务器发送 HTTP 请求 我们可以非常确定 Facebook 的主页没有被缓存到浏览器中，因为动态页面很快会过期甚至立即过期（把过期时间设置为过去某一时间点）。\n所以，浏览器会将请求发送到 Facebook 的服务器。\nGET http://facebook.com/ HTTP/1.1\rAccept: application/x-ms-application, image/jpeg, application/xaml+xml, [...]\rUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]\rAccept-Encoding: gzip, deflate\rConnection: Keep-Alive\rHost: facebook.com\rCookie: datr=1265876274-[...]; locale=en_US; lsd=WW[...]; c_user=2101[...]\rGET 请求说明这个 URL 是用来获取的 http://facebook.com 这个页面的 ，浏览器通过 header 中的 User-Agent 来标识自己（用户使用的操作系统及版本，浏览器及版本等等），通过 Accept 和 Accept-Encoding 规定接收哪种类型的响应信息。header 头 Connection 则要求服务器保持 TCP 连接保持连接状态以便于进一步请求。\n另外，这个请求还携带了浏览器在这个域名下的 cookie。你可能已经知道，cookie 是在不同页面中记录网站网站状态的键值对。也就是说，cookie 储存着登录用户的用户名、服务器分配给用户的密码、用户的一些设置等等。cookie 会被储存在客户端的一个文本文件中，每次请求都会一起发送给服务器端。\n 你可以通过很多工具去查看原生 HTTP 请求和对应的响应信息。我最喜欢的工具是 fiddler，但是仍然有很多别的工具（例如：Firebug），这些工具会给你很大的帮助当你优化一个网站的时候。\n  除了 GET 请求，另外你非常熟悉的另外一种类型的请求是 POST 请求，经常被用作表单提交。GET 请求通过它的 url 发送参数（例如：http://robozzle.com/puzzle.aspx?id=85）,而 POST 请求在 request body 中（就在 request header 下面）发送参数。\n  在 URL http://facebook.com/ 中，末尾的 / 是非常重要的。在这个例子中，浏览器可以很安全地在末尾增加 / 。而对于 URL http://example.com/folderOrFile，浏览器就不能自动增加一个 / ，因为浏览器不清楚 folderOrFile 是一个目录还是一个文件。在这种情况下，浏览器将会以不带 / 的形式访问这个 URL ，服务端将会返回一个重定向的响应信息，这就导致了一个不必要的请求和响应。\n 4. The facebook server responds with a permanent redirect 服务器响应并进行重定向\n这是 Facebook 服务端针对浏览器请求返回的响应信息。\nHTTP/1.1 301 Moved Permanently\rCache-Control: private, no-store, no-cache, must-revalidate, post-check=0,\rpre-check=0\rExpires: Sat, 01 Jan 2000 00:00:00 GMT\rLocation: http://www.facebook.com/\rP3P: CP=\u0026quot;DSP LAW\u0026quot;\rPragma: no-cache\rSet-Cookie: made_write_conn=deleted; expires=Thu, 12-Feb-2009 05:09:50 GMT;\rpath=/; domain=.facebook.com; httponly\rContent-Type: text/html; charset=utf-8\rX-Cnection: close\rDate: Fri, 12 Feb 2010 05:09:51 GMT\rContent-Length: 0\r服务端通过响应一个永久性转移的 HTTP 状态码来告诉浏览器去访问 http://www.facebook.com/ 而不是 http://facebook.com/ 。\n 关于服务端一定要将 http://facebook.com/ 重定向到 http://www.facebook.com/ ，而不是立即将用户希望看到的页面返回到浏览器，这里有一些有趣的原因。\n其中一个原因和搜索引擎排名有关。如有同一个页面有两个 URL，例如 http://www.igoro.com/ 和http://igoro.com/，搜索引擎可能会认为它们是两个不同的网站，每个 URL 的访问量都低于它们的总和就导致较低的排名。搜索引擎理解永久性转移（301），而且会将两个 URL 的点击量合并成一个单独的排名。\n同样的，相同内容对应多个 URL 是不利于缓存的。当一个内容拥有多个名字的时候，它将有可能被缓存多次。\n 5. The browser follows the redirect 浏览器向真正的服务器重新发送 HTTP 请求\n浏览器现在知道 http://www.facebook.com/ 才是应该访问的正确地址，因此它发送了另外一个 GET 请求\nGET http://www.facebook.com/ HTTP/1.1\rAccept: application/x-ms-application, image/jpeg, application/xaml+xml, [...]\rAccept-Language: en-US\rUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]\rAccept-Encoding: gzip, deflate\rConnection: Keep-Alive\rCookie: lsd=XW[...]; c_user=21[...]; x-referer=[...]\rHost: www.facebook.com\rheader 头的信息和第一次请求相同。\n6. The server ‘handles’ the request 服务器处理 HTTP 请求\n服务端将会接收到 GET 请求，然后加工处理并且返回一个响应信息。\n这看起来像是一个简单的任务，但实际上这里发生了很多有趣的事情 —— 即使是一个像我的博客这样简单的网站也是如此，更不用说像 Facebook 这样大规模可扩展的网站了。\nWeb server software web 服务器（如 IIS 或者 Apache）接收到 HTTP 请求然后决定运行哪一个请求处理程序去处理这个请求。一个请求处理程序（由 ASP、.NET、PHP、Ruby 等构建）是一个读取请求和生成 HTML 响应的程序。\n在这个简单的例子中，请求处理程序可以被储存在一个文件中xxx，例如 http://example.com/folder1/page1.aspx 这个 URL 会被映射到 /httpdocs/folder1/page1.aspx 这个文件。web 服务器同样也可以被配置，这样便于手工指定请求处理函数，因此文件 page1.aspx 对应的公开 URL 可以是 http://example.com/folder1/page1。\n 每一个动态网站都面临一个有意思的难题就是如何储存数据。小型网站通常会有一个 SQL 数据库去储存他们的数据，但是那些储存庞大数据或者拥有很多访客甚至两者兼具的网站，就必须找到一个方法通过多个服务器去将数据分割开。\n Request handler 请求处理程序读取请求，以及请求的参数和 cookie 。随后它会读取并且有可能更新一些存储在服务端的数据。然后，程序会生成 HTML 响应\n7. The server sends back a HTML response 服务器响应请求，返回 HTML 页面\n下面是服务端生成并返回的响应信息：\nHTTP/1.1 200 OK\rCache-Control: private, no-store, no-cache, must-revalidate, post-check=0,\rpre-check=0\rExpires: Sat, 01 Jan 2000 00:00:00 GMT\rP3P: CP=\u0026quot;DSP LAW\u0026quot;\rPragma: no-cache\rContent-Encoding: gzip\rContent-Type: text/html; charset=utf-8\rX-Cnection: close\rTransfer-Encoding: chunked\rDate: Fri, 12 Feb 2010 09:05:55 GMT\r2b3\r��������T�n�@����[...]\r响应信息数据大小为 36kb ，xxxxx\nheader 中字段 Content-Encoding\n1 2 3 4 5 6 7 8  \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34; id=\u0026#34;facebook\u0026#34; class=\u0026#34; no_js\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-language\u0026#34; content=\u0026#34;en\u0026#34; /\u0026gt; ...   除了压缩之外，header 头指定了是否缓存以及如何缓存这个页面，xxx cookie ，隐私信息，等等\n 注意这里的 header 头中 Content-Type 被设置为 text/html 。header 告知浏览器将响应内容（response content）当做 HTML 渲染，而不是文件进行下载。浏览器将会通过 header 去决定如何解释相应信息，但是也会参考其他因素，比如 URL 扩展内容。\n 8. The browser begins rendering the HTML 浏览器渲染 HTML 页面\n在浏览器接受全部的 HTML 文档信息之前，它就已经开始渲染网站了。\n9. The browser sends requests for objects embedded in HTML 浏览器请求静态资源，如 css 文件、图片、js 文件\n10. The browser sends further asynchronous (AJAX) requests 浏览器发送异步请求\n在 Web 2.0 时代，即使在页面渲染完毕，客户端也还是同服务端保持通信。\n例如，Facebook 聊天功能会保持更新你的朋友列表当他们进来或者离开。为了更新你的在记录中的朋友列表，你的浏览器中的 JavaScript 必须向服务端发送一个异步请求。这个异步请求时一个程序化构造的 GET 或者 POST 请求通过一个特殊的 URL。在 Facebook 这个例子中，客户端发送一个 POST 请求指向 http://www.facebook.com/ajax/chat/buddy_list.php ，它去获取一个关于你有哪些朋友在线的列表。\n这个模式有时叫做 AJAX ，代表着 Asynchronous JavaScript And XML，但即使这样也没有一个特殊的理由要求服务端必须把响应格式化为 XML 格式。例如，Facebook 在异步请求响应中返回 JavaScript 代码段。\n 通过 fiddler 可以查看浏览器发出的异步请求。事实上，你不仅可以被动地观察这些请求，你利用 fiddler 同样也可以修改和发送请求。\n  Facebook chat 提供了一个关于 AJAX 的有趣问题的一个例子：将数据从服务器推送到客户端。因为 HTTP 是一个请求-响应模式的协议，所以服务器不能向客户端发送新的消息。相反，客户端必须每隔几秒钟得到服务端的响应以便于查看是否有新的消息到达。\n长轮询是一个有趣的技巧，它可以减少\n 小结 关于 web 网站中各个部分如何协同工作，希望本文能对你有所启发。\n","description":"","id":59,"section":"posts","tags":null,"title":"「译」从 URL 输入到页面展现发生了什么","uri":"https://webjam.cn/posts/2019/what-really-happens-when-you-navigate-to-a-url/"},{"content":"背景 iframe 有两大烦人的东西，一是 iframe 高度问题，二是带遮罩的弹框提示。这两个问题都没什么处理经验，于是花点时间研究，基本实现了效果，于是记录下来以便备忘。\n本文为高度自适应问题的解决方案。\n实现 此方法前提条件：为方便获取 iframe 元素，需要知道该 iframe 的 id（当页面只有一个 iframe 元素时，使用类名或标签名也可以）。\n此处假设 iframe 元素的 id 为 iframe。\n为行文方便，后面将 iframe 元素指定的页面称为“子窗口或子页面”， iframe 元素所在的页面称为“父窗口”\njQuery 版 1 2 3  function resizeIframeParentHeight() { $(\u0026#34;#iframe\u0026#34;, window.parent.document).css(\u0026#39;height\u0026#39;, $(\u0026#39;body\u0026#39;).outerHeight()); }    此方法在子窗口中，在初次加载完成或者页面高度发生变化时执行 $(\u0026quot;#iframe\u0026quot;, window.parent.document) 获取父窗口中的 iframe 元素 $('body').outerHeight() 获取 iframe 元素指定页面的高度  js 版 您可以狠狠点击这里：js版iframe高度自适应demo\n1 2 3 4 5  function resizeIframeParentHeight() { var iframeHeight = document.body.scrollHeight; var iframe = window.parent.document.getElementById(\u0026#39;iframe\u0026#39;); iframe.style.height = iframeHeight + \u0026#39;px\u0026#39;; }    此方法在子窗口中，在初次加载完成或者页面高度发生变化时执行 window.parent 获取父窗口中 document ，则 window.parent.document.getElementById('iframe') 获取 iframe 元素 document.body.scrollHeight 获取 iframe 元素指定页面的高度  ","description":"","id":60,"section":"posts","tags":null,"title":"小tips - iframe 高度自适应","uri":"https://webjam.cn/posts/2019/iframe-height-auto/"},{"content":"小tips-使用正则获取查询字符串参数 一、什么是查询字符串 大部分开发者都应当对“查询字符串”不陌生，它随处可见。\n例如，当我们用百度搜索关键字 regexp 时，地址栏中 ? 后面的字符串就叫查询字符串。\n也就是说，https://www.baidu.com/s?ie=UTF-8\u0026amp;wd=regexp 中的 ie=UTF-8\u0026amp;wd=regexp 就是查询字符串。\n使用查询字符串的场景随处可见，如上面的网页地址中的查询字符串，还有 HTTP 协议中的 GET 请求也是将参数拼接成查询字符串的形式。\n二、解析查询字符串 前端开发过程中，通过查询字符串传递参数是一个常见的场景。那么就需要这么一个操作查询字符串的处理：从 url 中获取查询字符串，然后将查询字符串解析成方便处理的 json 对象。\n获取查询字符串并打印：\n1 2 3 4 5  // 假设此时的 URL 是：https://www.baidu.com/s?ie=UTF-8\u0026amp;wd=regexp var querystring = window.location.search.slice(1); console.log(querystring); // \u0026#34;ie=UTF-8\u0026amp;wd=regexp\u0026#34;   location 挂载在全局对象 window 上，其属性 search 指的是 URL 中问号 ? 之后的部分（包含 ?），即 ?ie=UTF-8\u0026amp;wd=regexp，通过 String.prototype.slice() 提取其中除 ? 之外所有内容，即可得到查询字符串。\n下面是将查询字符串解析成 json 对象的几种思路。\n方法一：split  通过 split 方法，指定 \u0026amp; 为分隔符，得到处理后的数组 [\u0026quot;ie=UTF-8\u0026quot;, \u0026quot;wd=regexp\u0026quot;] 遍历数组，同样通过 split 方法，指定 = 为分隔符，得到 [\u0026quot;ie\u0026quot;, \u0026quot;UTF-8\u0026quot;] 和 [\u0026quot;wd\u0026quot;, \u0026quot;regexp\u0026quot;] 遍历获取的数组中第一项则为键，第二项为对应的值，赋值给 json  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var querystring = window.location.search.slice(1); // \u0026#34;ie=UTF-8\u0026amp;wd=regexp\u0026#34; var json = parse(querystring); console.log(json); // {ie: \u0026#34;UTF-8\u0026#34;, wd: \u0026#34;regexp\u0026#34;}  function parse (querystring) { var querystring = querystring || \u0026#39;\u0026#39;; var queryArray = querystring.split(\u0026#39;\u0026amp;\u0026#39;); // [\u0026#34;ie=UTF-8\u0026#34;, \u0026#34;wd=regexp\u0026#34;]  var json = {}; queryArray.forEach(function (item, index) { var tmp = item.split(\u0026#39;=\u0026#39;); // [\u0026#34;ie\u0026#34;, \u0026#34;UTF-8\u0026#34;]  // [\u0026#34;wd\u0026#34;, \u0026#34;regexp\u0026#34;]  json[tmp[0]] = tmp[1]; }) return json }   方法二：replace + regexp 先上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13  var querystring = window.location.search.slice(1); parse(querystring); function parse (querystring) { var querystring = querystring || \u0026#39;\u0026#39;; var reg = /([^=\u0026amp;]+)=([^=\u0026amp;]*)/ig; var json = {}; querystring.replace(reg, function (match, $1, $2) { json[$1] = $2 }) return json; }    利用字符串的 replace 方法，如果第一个参数是正则表达式， 并且其为全局匹配模式，同时第二个参数是一个函数，那么每次匹配到的时候，这个函数都会被调用。 正则 /([^=\u0026amp;]+)=([^=\u0026amp;]*)/ig 的含义为，使用 = 连接，且 = 前后的字符串都不能以 = 或者 \u0026amp; 开头。\n  function 参数含义：\n 匹配字符串 正则表达式分组内容，没有分组则没有该参数 匹配项在字符串中的 index 原字符串      match $1 $2 index origin     第一次 ie=UTF-8 ie UTF-8 0 ie=UTF-8\u0026amp;wd=regexp   第二次 wd=regexp wd regexp 9 ie=UTF-8\u0026amp;wd=regexp    正则表达式的含义  String.prototype.split() · MDN String.prototype.slice() · MDN String.prototype.replace() · MDN  ","description":"","id":61,"section":"posts","tags":null,"title":"小tips-使用正则获取查询字符串参数","uri":"https://webjam.cn/posts/2019/parse-querystring/"},{"content":"切换浏览器 tab 标签时动态设置网页 效果 在饿了么官网看到一个网页效果，在饿了么网页和其他标签页之间相互切换时，饿了么网页的 type: post\ntitle，发生了变化。\n饿了么官网: https://www.ele.me/home/\n效果如下：\n代码实现 预备知识  visibilitychange 事件，会在浏览器标签页被隐藏或显示的时候会触发 document.hidden ，只读属性，返回一个布尔值标识当前页面是否隐藏 document.visibilityState，只读属性，返回 document 的可见性，有 4 个值：   visible : 此时页面内容至少是部分可见。 即此页面在前景标签页中，并且窗口没有最小化 hidden : 此时页面对用户不可见。即文档处于背景标签页或者窗口处于最小化状态，或者操作系统正处于锁屏状态 prerender : 页面此时正在渲染中， 因此是不可见的. 文档只能从此状态开始，永远不能从其他值变为此状态 unloaded : 页面从内存中卸载清除  具体实现  使用 document.hidden 属性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var type: post titleFocus = \u0026#39;饿了么\u0026#39;; var type: post titleBlur = \u0026#39;记得回来哦\u0026#39;; function toggletype: post titleHandler(bool) { document.type: post title = bool ? type: post titleBlur : type: post titleFocus; } document.addEventListener(\u0026#34;visibilitychange\u0026#34;, function () { toggletype: post titleHandler(document.hidden); }, false);    使用 document.visibilityState 属性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var type: post titleFocus = \u0026#39;饿了么\u0026#39;; var type: post titleBlur = \u0026#39;记得回来哦\u0026#39;; function toggletype: post titleHandler(visibilityState) { document.type: post title = visibilityState === \u0026#39;hidden\u0026#39; ? type: post titleBlur : type: post titleFocus; } document.addEventListener(\u0026#34;visibilitychange\u0026#34;, function () { toggletype: post titleHandler(document.visibilityState); }, false);   其他 此 API 存在兼容性问题，支持 IE10+\n推荐阅读： Page Visibility(页面可见性) API介绍、微拓展 - 张鑫旭（PS：此处献上我的膝盖）\n","description":"","id":62,"section":"posts","tags":null,"title":"切换浏览器 tab 标签时动态设置网页","uri":"https://webjam.cn/posts/2019/toggle-title-on-focus-and-blur/"}]