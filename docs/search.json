[{"categories":["bug-fix"],"content":" 监听事件bindready，获取高度有时不准确 #195  对应的源码部分  判断 ready 的标准是每 350ms 检查一次高度，两次高度不变化就认为加载完毕，然后返回大小，处理的地方在 这里\n这个处理方式确实可能在某些情况下不准确，如果 350ms 总高度不变化就会触发，但这个很难权衡，因为要确保一定准确的话可能这个时间间隔要更长或者多次不变化后再触发，这样的话触发的就会很慢，某些情况下会带来问题（比如进入页面后等待图片加载完要跳转到某个锚点，等待时间过长就会影响体验），所以这里如果要求很高的话可能需要自行调整一下\nps：对于这个问题最准确的获取时机应该是所有图片都触发 load 事件的时候，但由于开启懒加载后，一些图片不会立即加载，所以无法判断是否全部加载完毕，以及另外一些原因这个方法不适用，所以只能通过高度变化判断\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  export default { data () { return { _timer: null } }, method () { /** * @description 获取内容大小和位置 * @return {Promise} */ getRect (selector) { return new Promise((resolve, reject) =\u003e { uni.createSelectorQuery() // #ifndef MP-ALIPAY \t.in(this) // #endif \t.select(selector).boundingClientRect().exec(res =\u003e res[0] ? resolve(res[0]) : reject(Error('Root label not found'))) }) }, watchGoodsDetail () { let times = 0; // 监听次数 \tlet maxTimes = 10; // 连续 10 获取高度相同视为加载完毕 \tlet wait = 350; // 间隔 \tlet height = 0; // 详情高度  clearInterval(this._timer) this._timer = setInterval(() =\u003e { this.getRect('#tab3').then(rect =\u003e { // 350ms 总高度无变化就触发 ready 事件 \tif (rect.height === height) { times++ if (times \u003e= maxTimes) { clearInterval(this._timer) } } else { times = 0 height = rect.height this.onNavTargetChange() } }).catch(() =\u003e { }) }, wait) } } }   ","description":"","tags":["源码","uniapp","mp-html"],"title":"解决 uView Parse 富文本解析器 ready 事件触发时机不准确的问题","uri":"/2021-07-15/temp/"},{"categories":["其他"],"content":"参考文章： git subtree教程 1  git subtree push --prefix=content/posts post master   目前主要使用这三个命令即可，分别是添加、更新和推送远程。\n1 2 3  git subtree add --prefix=\u003cprefix\u003e \u003crepository\u003e \u003cref\u003e git subtree pull --prefix=\u003cprefix\u003e \u003crepository\u003e \u003cref\u003e git subtree push --prefix=\u003cprefix\u003e \u003crepository\u003e \u003cref\u003e   其中 \u003cprefix\u003e 是子模块的路径，\u003crepository\u003e 是子模块自身的 git 地址。\n1 2 3 4 5 6 7 8  { \"scripts\": { \"set:posts\": \"git remote add posts git@github.com:wencaizhang/wencaizhang.github.io.git\", \"add:posts\": \"git subtree add --prefix=content/posts post master \", \"pull:posts\": \"git subtree pull --prefix=content/posts post master \", \"push:posts\": \"git subtree push --prefix=content/posts post master\" } }   ","description":"","tags":["git"],"title":"git subtree 使用记录","uri":"/2021-07-09/git-subtree/"},{"categories":["其他"],"content":"Git 是程序员日常开发离不开的工具，合并分支也是多人开发协作过程中必不可少的环节。\n","description":"","tags":["git"],"title":"一个合并分支的新姿势","uri":"/2021-07-09/git-merge-squash/"},{"categories":["短代码"],"content":"设置input占位符的样式\nHTML 代码：\n1  \u003cinput type=\"text\" placeholder=\"请设置用户名\"\u003e   CSS 代码：\n1 2 3 4 5 6 7 8 9 10 11 12  input::-webkit-input-placeholder { /* Chrome/Opera/Safari */ color: red; } input::-moz-placeholder { /* Firefox 19+ */ color: red; } input:-ms-input-placeholder { /* IE 10+ */ color: red; } input:-moz-placeholder { /* Firefox 18- */ color: red; }   示例：\n input::-webkit-input-placeholder { /* Chrome/Opera/Safari */ color: red; } input::-moz-placeholder { /* Firefox 19+ */ color: red; } input:-ms-input-placeholder { /* IE 10+ */ color: red; } input:-moz-placeholder { /* Firefox 18- */ color: red; } ","description":"","tags":["CSS","placeholder"],"title":"设置input的placeholder的字体样式","uri":"/2021-06-06/set-styles-of-input-placeholder/"},{"categories":["短代码"],"content":"设置input占位符的样式\nHTML 代码：\n1 2 3  \u003cp class=\"scroll-container\"\u003e 庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。 \u003c/p\u003e   CSS 代码：\n1 2 3 4 5 6 7  .scroll-container { width: 500px; height: 150px; border: 1px solid #ddd; padding: 15px; overflow: auto; /*必须*/ }   滚动条样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  .scroll-container::-webkit-scrollbar { width: 8px; background: white; } .scroll-container::-webkit-scrollbar-corner, /* 滚动条角落 */ .scroll-container::-webkit-scrollbar-thumb, .scroll-container::-webkit-scrollbar-track { /*滚动条的轨道*/ border-radius: 4px; } .scroll-container::-webkit-scrollbar-corner, .scroll-container::-webkit-scrollbar-track { /* 滚动条轨道 */ background-color: rgba(180, 160, 120, 0.1); box-shadow: inset 0 0 1px rgba(180, 160, 120, 0.5); } .scroll-container::-webkit-scrollbar-thumb { /* 滚动条手柄 */ background-color: #00adb5; }   示例：\n庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。  .scroll-container { width: 500px; height: 150px; border: 1px solid #ddd; padding: 15px; overflow: auto; } .scroll-container::-webkit-scrollbar { width: 8px; background: white; } .scroll-container::-webkit-scrollbar-corner, /* 滚动条角落 */ .scroll-container::-webkit-scrollbar-thumb, .scroll-container::-webkit-scrollbar-track { border-radius: 4px; } .scroll-container::-webkit-scrollbar-corner, .scroll-container::-webkit-scrollbar-track { /* 滚动条轨道 */ background-color: rgba(180, 160, 120, 0.1); box-shadow: inset 0 0 1px rgba(180, 160, 120, 0.5); } .scroll-container::-webkit-scrollbar-thumb { /* 滚动条手柄 */ background-color: #00adb5; } ","description":"","tags":["CSS","scrollbar"],"title":"设置滚动条样式","uri":"/2021-06-06/set-styles-of-scrollbar/"},{"categories":["其他"],"content":"作为软件开发工程师多多少少都该懂一些 nginx 的使用和配置，下面是 nginx 的几个经典应用场景下的配置写法，记录下来以防遗忘，用到的时候也可以直接过来拷贝。\n端口监听 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  server { # Standard HTTP Protocol  # 标准的 HTTP 协议  listen 80; # Standard HTTPS Protocol  # 标准的 HTTPS 协议  listen 443 ssl; # For http2  listen 443 ssl http2; # Listen on 80 using IPv6  # 使用 IPv6 监听 80 端口  listen [::]:80; # Listen only on using IPv6  # 仅使用 IPv6 监听 80 端口  listen [::]:80 ipv6only=on; }   访问日志 1 2 3 4 5 6 7 8 9  server { # Relative or full path to log file  # 为日志文件指定一个相对或绝对路径  access_log /path/to/file.log; # Turn 'on' or 'off'  # 通过 'on' 或者 'off' 控制是否启用  access_log on; }   域名 指定域名和对应的网站根目录位置，server_name 可以是域名、二级域名，也可以是 ip 地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  server { # Listen to yourdomain.com  # 监听来自域名 yourdomain.com 的访问  server_name yourdomain.com; # Listen to multiple domains  # 监听来自多个域名的访问  server_name yourdomain.com www.yourdomain.com; # Listen to all domains  # 监听 yourdomain.com 的所有二级域名  server_name *.yourdomain.com; # Listen to all top-level domains  # 监听所有 yourdomain 的顶级域名  server_name yourdomain.*; # Listen to unspecified Hostnames (Listens to IP address itself)  # 不指定域名，监听自身 IP 的访问  server_name \"\"; }   静态资源访问 1 2 3 4 5 6 7 8  server { listen 80; server_name yourdomain.com; location / { root /path/to/website; } }   重定向 1 2 3 4 5  server { listen 80; server_name www.yourdomain.com; return 301 http://yourdomain.com$request_uri; }   1 2 3 4 5 6 7 8 9  server { listen 80; server_name www.yourdomain.com; location /redirect-url { return 301 http://otherdomain.com; } }   反向代理 1 2 3 4 5 6 7 8 9 10 11  server { listen 80; server_name yourdomain.com; location / { proxy_pass http://0.0.0.0:3000; # where 0.0.0.0:3000 is your application server (Ex: node.js) bound on 0.0.0.0 listening on port 3000  } }   负载均衡 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  upstream node_js { server 0.0.0.0:3000; server 0.0.0.0:4000; server 123.131.121.122; } server { listen 80; server_name yourdomain.com; location / { proxy_pass http://node_js; } }   SSL 证书 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  server { listen 443 ssl; server_name yourdomain.com; ssl on; ssl_certificate /path/to/cert.pem; ssl_certificate_key /path/to/privatekey.pem; ssl_stapling on; ssl_stapling_verify on; ssl_trusted_certificate /path/to/fullchain.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_timeout 1h; ssl_session_cache shared:SSL:50m; add_header Strict-Transport-Security max-age=15768000; } # Permanent Redirect for HTTP to HTTPS # 将 HTTP 访问永久重定向到 HTTPS server { listen 80; server_name yourdomain.com; return 301 https://$host$request_uri; }   感谢 文中用到的配置几乎都出自 https://vishnu.hashnode.dev/nginx-cheatsheet 这篇文章，在此基础上经过个人理解添加了一些解释说明，特此说明。\n","description":"","tags":["nginx","备忘"],"title":"Nginx 常用配置备忘清单 | nginx-cheatsheet","uri":"/2021-05-18/nginx-cheatsheet/"},{"categories":["短代码"],"content":"more 利用 HTML5 原生的 download 属性来下载文本信息\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /** * 前端创建并下载文件 * @param {String} content 文件内容 * @param {String} filename 文件名称 * @param {String} MIME * MIME类型参考手册 http://www.w3school.com.cn/media/media_mimeref.asp */ export function downloadFile (content, filename, MIME = 'application/octet-stream') { // 创建隐藏的可下载链接  const eleLink = document.createElement('a') eleLink.download = filename eleLink.style.display = 'none' // 字符内容转变成blob地址  const blob = new Blob([content], { type: MIME }) eleLink.href = URL.createObjectURL(blob) // 触发点击事件，然后移除  document.body.appendChild(eleLink) eleLink.click() document.body.removeChild(eleLink) }   其中，参数 content 指需要下载的文本或字符串内容，filename 指下载到系统中的文件名称。\n代码来源： JS前端创建html或json文件并浏览器导出下载 ","description":"","tags":["JavaScript"],"title":"前端创建并下载文件","uri":"/2021-01-27/download-file/"},{"categories":["短代码"],"content":"使用 JavaScript 内置方法将正常时间格式转化为时间戳\n1 2 3 4 5 6 7 8 9 10 11  /** * 将正常时间格式转化为时间戳 * @param {String} time [正常时间格式，如：2019-04-01 13:10:10] */ export function getTimestamp (time = null) { // 没有对 time 做合法性校验  // 假设传入的 time 都是合法的时间格式：2019-04-01 13:10:10  const date = time ? new Date(time.replace(/-/g, '/')) : new Date() const timestamp = date.getTime() // 13 位数字，精确到毫秒  return timestamp }   ","description":"","tags":["JavaScript","日期"],"title":"将正常时间格式转化为时间戳","uri":"/2021-01-27/transform-timestamp/"},{"categories":["短代码"],"content":"在开发移动端网站时经常需要检查用户端设备类型，以便做出不同的调整。\n方式一、检测手机平板和PC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function detectDevice() { var isMobile = false, isTablet = false, isLaptop = false; if (window.innerWidth \u003c= 425) { isMobile = true; isTablet = false; isLaptop = false; } else if (window.innerWidth \u003c= 768) { isMobile = false; isTablet = true; isLaptop = false; } else { isMobile = false; isTablet = false; isLaptop = true; } } detectDevice();   判断是否微信浏览器 1 2 3 4  function isWeChat () { const ua = navigator.userAgent.toLowerCase() return ua.match(/MicroMessenger/i) == \"micromessenger\" }   ","description":"","tags":["JavaScript"],"title":"检测设备类型","uri":"/2021-01-27/detect-device/"},{"categories":["短代码"],"content":"某些时候我们需要展示某个时间点相差当前时刻多久，例如“一天前”，“一个月前”等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  /** * 计算传入的时间戳和当前时间相差了多久 * @param {Number} timestamp [时间戳] */ export function getTimeDiff (timestamp) { // 如果精确到毫秒，时间戳是 13 位数字  // 这里按照秒来计算，需要将毫秒转换为秒  if (timestamp \u003e 1 * 10 ** 12) { timestamp = timestamp / 1000 } var currentStamptime = Date.parse(new Date()) / 1000 var agoAt = '刚刚' var diff = currentStamptime - timestamp var points = [ { value: 365 * 24 * 60 * 60, suffix: '年前', max: 2 }, { value: 30 * 24 * 60 * 60, suffix: '月前', max: 11 }, { value: 7 * 24 * 60 * 60, suffix: '周前', max: 4 }, { value: 24 * 60 * 60, suffix: '天前', max: 6 }, { value: 60 * 60, suffix: '小时前', max: 23 }, { value: 10 * 60, suffix: '0分钟前', max: 5 } ] for (var i = 0; i \u003c points.length; i++) { var item = points[i] var mode = Math.floor(diff / item.value) if (mode \u003e= 1) { agoAt = Math.min(mode, item.max) + item.suffix break } } return agoAt }   ","description":"","tags":["JavaScript","日期"],"title":"计算传入的时间戳和当前时间相差了多久","uri":"/2021-01-27/get-time-ago/"},{"categories":["短代码"],"content":"我们知道存储容量好几个不同的单位，如 KB、MB、GB 等等。\n而在反映一块硬盘的具体容量时，总是需要根据其实际大小选用合适的单位，例如我有一块 500GB 的硬盘和一根 4GB 的内存条，就不能说成 0.5GB 的硬盘和 4000MB 的内存条。\n因此，我们需要一个函数来将一个容量转换为合适的单位来表示\n转换存储容量大小\nvalue 应当是以 b 位单位的 小于 1 KB，则转化成 B 小于 1 MB，则转化成 KB 小于 1 GB，则转化成 MB 以此类推，目前最大单位 PB size: 单位大小，这里是 1000\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  export function formatStorageSize (currValue = 0, unit = 'B', size = 1024) { const unites = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'] if (!unites.includes(unit)) { return new Error('请输入标准的存储单位') } const powSize = n =\u003e { const max = unites.length return max \u003e n ? Math.pow(size, n) : Infinity } const unitesTable = unites.map((unit, index) =\u003e { return { suffix: unit, minValue: 1 * powSize(index), maxValue: 1 * powSize(index + 1) } }) console.log(unitesTable) // 先恢复到以 B 为单位然后进行计算  const value = powSize(unites.indexOf(unit)) * currValue const { suffix, minValue } = unitesTable.find(item =\u003e item.maxValue \u003e value) const ret = (value / minValue).toFixed(2) + ' ' + suffix return ret }   测试代码 1    ","description":"","tags":["JavaScript"],"title":"转换存储容量大小","uri":"/2021-01-27/transform-size/"},{"categories":["短代码"],"content":"想让你的网页可以 blingbling 地闪耀吗？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  .flash-wrap { position: relative; overflow: hidden; } .flash-wrap::after { content: \"\"; position: absolute; left: -100%; top: 0; width: 100%; height: 100%; transform: skewx(-25deg); background-image: -webkit-linear-gradient(0deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .5), rgba(255, 255, 255, 0)); z-index: 10; } .flash-wrap:hover::after { animation: flash 2s ease infinite; animation-delay: .5s; } @keyframes flash { 0% { left: -100%; } 100% { left: 100%; } }   ","description":"","tags":["JavaScript"],"title":"闪耀你的div","uri":"/2021-01-27/flash/"},{"categories":["其他"],"content":"在 JavaScript 中彻底解决你0.1+0.2!==0.3的精度问题，还可以给小数按条件取值。是开发计算项目的必备良品\n本篇推荐三个可用于 JavaScript 中数字计算不丢失精度的开源库，均由 MikeMcl 开源（给大佬点赞👍），三个库的 API 保持一致，但侧重点不同，下面一一解释。\n一、big.js 传送门： https://github.com/MikeMcl/big.js 文档： https://mikemcl.github.io/big.js/ 适合只需要简单计算的项目\n二、bignumber.js 传送门： https://github.com/MikeMcl/bignumber.js 文档： https://mikemcl.github.io/bignumber.js/ 可以对小数进行向上或向下取值，适合金融类项目\n三、decimal.js 传送门： https://github.com/MikeMcl/decimal.js 文档： http://mikemcl.github.io/decimal.js decimal.js 提供了很多数学计算相关的函数，例如正弦余弦对数等函数，非常适合数学计算类需要运行很多数学函数的项目。\n","description":"","tags":["其他","工具","开源库"],"title":"推荐 JavaScript 中处理数字计算精度问题的开源库","uri":"/2021-01-10/calculate-of-number-in-js/"},{"categories":["其他"],"content":"每次写文章给博文配图是一件很麻烦的事情，一张张地找，有时候质量还不好，于是乎，我就去寻找了一波背景图api接口，这下妈妈再也不用担心我文章不会配图了，\nAPI 调用方式很简单，就是直接把 api 地址当做图片地址来访问，当服务器接收到访问时会自动重定向到一个随机的图片地址。\n下面列举几个\n一、小歪API 网址: https://api.ixiaowai.cn/  目前系统共收录 1000+ 张图片 API最后更新时间:2020-03-25\n图片均为https，采用新浪图片，高速访问\n 1.1 直接使用   图片API基本调用格式：\n 二次元动漫: https://api.ixiaowai.cn/api/api.php  mc酱动漫: https://api.ixiaowai.cn/mcapi/mcapi.php  高清壁纸: https://api.ixiaowai.cn/gqapi/gqapi.php     文字API基本调用格式：\n 一言语录: https://api.ixiaowai.cn/ylapi/index.php  舔狗日记: https://api.ixiaowai.cn/tgrj/index.php     1.2 JSON 格式 访问上面的 api 会直接重定向到一个随机图片地址，你可以在 api 后面添加参数 type=json 来得到一个 JSON 格式的结果：\n例如：\n 图片列： https://api.ixiaowai.cn/api/api.php?return=json  文字列： https://api.ixiaowai.cn/ylapi/index.php/?code=js   返回 JSON 数据示例\n1 2 3 4 5 6  { \"code\": \"200\", \"imgurl\": \"https://tva3.sinaimg.cn/large/0072Vf1pgy1fodqoysytvj31hc0u0qcq.jpg\", \"width\": \"1920\", \"height\": \"1080\" }   二、动漫星空 目前 动漫星空 共收录 8千万+ 张4K精美图片 动漫星空随机图片API，高速，免费，无广告 注意： 目前仅提供1080P接口，2K和4K接口后续开放，更多动态请持续关注 动漫星空API官网 及 动漫星空微信公众号 ，第一时间获取官方更新信息 HTML调用格式 1080P：\nhttps://api.dongmanxingkong.com/suijitupian/acg/1080p/index.php 参数： type=json JSON调用格式 1080P：\nhttps://api.dongmanxingkong.com/suijitupian/acg/1080p/index.php?return=json JSON数据\n1 2 3 4 5 6  { \"code\": \"200\", \"imgurl\": \"https://tvax2.sinaimg.cn/large/0072Vf1pgy1fodqpio0roj31kw0v47wh.jpg\", \"width\": \"2048\", \"height\": \"1120\" }   三秋API接口站 目前系统共收录 3k9+ 张图片 API最后更新时间:2020-07-14\n图片均为https，采用又拍云存储，高速访问\n 自判断二次元API： https://api.ghser.com/random/api.php  PC随机二次元API： https://api.ghser.com/random/pc.php  PE随机二次元API： https://api.ghser.com/random/pe.php  随机二次元风景API： https://api.ghser.com/random/bg.php   ","description":"","tags":["其他","工具"],"title":"给博客搭配随机图片","uri":"/2021-01-08/random-image-for-blog/"},{"categories":["短代码"],"content":"当用户登录你的系统时，如果能够给出一个友好有趣的提示语，想必更能让你的用户感受到开发者的用心。\n今天分享一个当用户登入系统的友好提示语：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function timeFix () { const time = new Date() const hour = time.getHours() const timeMap = { 9: '早上好', 11: '上午好', 13: '中午好', 20: '下午好', 24: '晚上好' } const key = Object.keys(timeMap).find(key =\u003e hour \u003c= key) return timeMap[key] } function welcome () { const arr = ['休息一会儿吧', '准备吃什么呢?', '要不要打一把 DOTA', '我猜你可能累了'] const index = Math.floor(Math.random() * arr.length) return arr[index] }   点我试试\n function timeFix () { const time = new Date() const hour = time.getHours() const timeMap = { 9: '早上好', 11: '上午好', 13: '中午好', 20: '下午好', 24: '晚上好' } const key = Object.keys(timeMap).find(key = hour ","description":"","tags":["JavaScript"],"title":"欢迎提示语分享","uri":"/2020-12-29/welcome-message/"},{"categories":["设计模式"],"content":"背景交代 最近负责的一个前端项目随着需求和功能的升级，代码越写越复杂，尤其是登录模块的判断逻辑，就像是那老太太的缠脚布——又臭又长!\n刚好趁着登录的需求变更，使用责任链模式把相关代码重构了一番，重构之后再看代码，啧啧，代码之整洁且逻辑清晰，忍不住要给自己送一朵小红花 🌺 —— 优秀！\n撸起袖子加油干 我们约定好，将单个判断逻辑封装成一个函数，函数接收相同的参数，返回值的统一为一个 promise。\n如果判断通过，可以进行下一步判断，返回 fulfill 状态的 promise，如果未通过需要结束后续判断，则返回 rejected 状态的 promise。\n这里的代码均为示意代码，其中的判断逻辑都进行了简化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function handlePwdExpired (resp) { if (resp.expired === 1) { // 密码过期处理逻辑  console.log('密码过期，请修改密码后重新登录') return Promise.rejected('密码过期') } return Promise.resolve(resp) } function handleAuthStatus (resp) { if (resp.status === 1) { return Promise.resolve(resp) } // 实名认证未通过处理逻辑  console.log('实名认证未通过，请耐心等待') return Promise.rejected('实名认证未通过') } function handleDefault (resp) { console.log('逻辑判断结束，进入系统') }   定义好上面处理策略之后，我们来调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 假定我们已经拿到了响应 const resp = { status: 1, expired: 1, } Promise.resolve(resp) .then(resp =\u003e { return handlePwdExpired(resp) }) .then(resp =\u003e { return handleAuthStatus(resp) }) .then(resp =\u003e { return handleDefault(resp) }) .catch(err =\u003e { console.log(err); })   ","description":"使用责任链模式降低代码耦合度，可以有效减少心智负担","tags":["责任链模式","promise","代码重构"],"title":"责任链模式","uri":"/2020-12-12/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"背景交代 场景一：转换数据格式 Vue 中的 computed 属性就是现成的一个适配器：\n1 2 3 4 5 6 7 8 9 10  const vm = new Vue({ data: { authors: [ '张教授', '王教授'] }, computed: { authorsText () { return this.authors.join('、') } } })   又比如\n撸起袖子加油干 ","description":"","tags":["适配器模式","代码重构"],"title":"适配器模式","uri":"/2020-12-12/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["CSS"],"content":"一、单行省略 1 2 3  \u003cdiv class=\"elip w100\" style=\"border: 1px solid #5184f6;\"\u003e 两个黄鹂鸣翠柳，一行白鹭上青天。窗含西岭千秋雪，门泊东吴万里船。 \u003c/div\u003e   1 2 3 4 5 6 7 8 9 10 11 12 13  /* 单行文本溢出省略 */ .elip { /* 隐藏溢出内容 */ overflow: hidden; /* 不换行，强制文本在一行显示 */ white-space: nowrap; /* 溢出的部分进行省略 */ text-overflow: ellipsis; } .w100 { /* 设置宽度，一定不要忘了 */ width: 100px; }   效果如下：\n .elip { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .w100 { width: 100px; }  两个黄鹂鸣翠柳，一行白鹭上青天。窗含西岭千秋雪，门泊东吴万里船。  要想实现单行文本超出宽度省略，需要满足以下几点\n只要满足了上面 4 点，单行文本的溢出省略就很容易实现。但现实情况中，除了单行文本外还有很多场景是需要实现多行文本溢出省略的，接下来我们一起来看如何实现这个需求。\n二、多行文本溢出省略 之所以说多行文本溢出省略不容易实现，是因为在 CSS 规范中 text-overflow: ellipsis 只适用于单行文本，同时并没有适用于多行文本溢出省略的规则。因此我们只能另辟蹊径来实现这个需求。\n使用浏览器私有属性来实现 1 2 3 4 5 6 7 8  .box { width: 200px; padding: 0 !important; /* padding 必须为 0 */ overflow: hidden; display: -webkit-box; /* 类似于 flexbox 的自适应布局 */ -webkit-box-orient: vertical; /* 元素排列方向：从上到下 */ -webkit-line-clamp: 4; /* 第四行后开始省略 */ }    .box { width: 200px; padding: 0; overflow: hidden; display: -webkit-box; /* 类似于 flexbox 的自适应布局 */ -webkit-box-orient: vertical; /* 元素排列方向：从上到下 */ -webkit-line-clamp: 4; /* 第四行后开始省略 */ } .border { border: 1px solid #ccc; }  有一天，螃蟹撞到了田螺。田螺说:“蟹蟹，你撞到我了”，螃蟹说:“不用谢”。田螺回道:“谢你妹啊，我是说你撞到我了，你是不是瞎啊”，螃蟹一脸委屈地说:“我不是虾啊，我是螃蟹” 有一天，螃蟹撞到了田螺。田螺说:“蟹蟹，你撞到我了”，螃蟹说:“不用谢”。田螺回道:“谢你妹啊，我是说你撞到我了，你是不是瞎啊”，螃蟹一脸委屈地说:“我不是虾啊，我是螃蟹”\n 其中 padding 必须保证为 0，否则立马破功，这一点很容易被忽略掉，有兴趣的可以测试一下。\n这种方法的优点是写法简洁明了（相对于使用 js 截取文本），但缺点就是通过私有属性实现，不过经测试在 chrome、firefox、safari 以及移动端和小程序都能生效，所以大部分场景还是可以使用这个方法的。\n有一天，螃蟹撞到了田螺。田螺说:“蟹蟹，你撞到我了”，螃蟹说:“不用谢”。田螺回道:“谢你妹啊，我是说你撞到我了，你是不是瞎啊”，螃蟹一脸委屈地说:“我不是虾啊，我是螃蟹”  p { height: 210px; overflow: hidden; position: relate } p::before { content: \"...\"; }  https://wencaizhang.github.io/study/p/elip.html ### -- 三、代码总结 原理搞明白之后，为了更方便地在项目中使用，我整理出来了这段 CSS 代码，其中预设了 5 个 class 样式，类名都是 elip-line-x 的格式，其中 x 代表你想要最多展示 x 行文字，取值范围是 1-5。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* start--文本行数限制--start */ .elip-line-1 { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .elip-line-2, .elip-line-3, .elip-line-4, .elip-line-5 { padding: 0 !important; overflow: hidden; word-break: break-all; text-overflow: ellipsis; display: -webkit-box; -webkit-box-orient: vertical; } .elip-line-2 { -webkit-line-clamp: 2; } .elip-line-3 { -webkit-line-clamp: 3; } .elip-line-4 { -webkit-line-clamp: 4; } .elip-line-5 { -webkit-line-clamp: 5; } /* end--文本行数限制--end */   有了上面这段代码，直接给任意元素加上 elip-line-x 类即可轻松实现最多 x 行文字显示省略号点点点效果。如果最多显示 5 行不满足你的需求，你也可以根据代码扩展到任意行数。\n","description":"CSS多行文本溢出显示省略号显示点点点...","tags":["css","文本溢出"],"title":"CSS多行文本溢出显示省略号显示点点点...","uri":"/2020-06-28/css-text-overflow-ellipsis/"},{"categories":null,"content":" 根据 moment.js 得到一个单位时间或者时间段（如本周，上周，本月，上月，当前季度，上个季度）的开始结束时间\n   momentjs 文档   主要利用以下几项 API：\n format(): 得到格式化的时间 startOf(): 得到一个单位时间的开始时间点， 文档  endOf(): 得到一个单位时间的结束时间点 add(): 在指定时间点的基础上，加上一个时间段 subtract(): 在指定时间点的基础上，减去一个时间段 week(): 获取或设置一个时间对象的周数（第几周） month(): 获取或设置一个时间对象的月份 quarter(): 获取或设置一个时间对象的季度  天 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 获取当天开始结束时间 function getCurrDays () { let date = moment() let start = date.startOf('days').format('YYYY-MM-DD HH:mm:ss') let end = date.endOf('days').format('YYYY-MM-DD HH:mm:ss') return [ start, end ] } // 获取昨天的开始结束时间 function getYesterday () { let date = moment().subtract('days',1); let start = date.startOf('days').format('YYYY-MM-DD HH:mm:ss') let end = date.endOf('days').format('YYYY-MM-DD HH:mm:ss') return [ start, end ] } // 获取明天的开始结束时间 function getTomorrow () { let date = moment().add('days',1); let start = date.startOf('days').format('YYYY-MM-DD HH:mm:ss') let end = date.endOf('days').format('YYYY-MM-DD HH:mm:ss') return [ start, end ] }   周 获取某一周（本周，上周，下周）的开始结束时间，一周从周日开始到周六结束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 本周 function getCurrWeekDays () { let date = moment() let start = date.startOf('week').format('YYYY-MM-DD HH:mm:ss') let end = date.endOf('week').format('YYYY-MM-DD HH:mm:ss') return [ start, end ] } // 上一周 function getLastWeekDays () { let date = moment().week(moment().week() - 1) let start = date.startOf('week').format('YYYY-MM-DD HH:mm:ss') let end = date.endOf('week').format('YYYY-MM-DD HH:mm:ss') return [ start, end ] } // 下一周 function getNextWeekDays () { let date = moment().week(moment().week() + 1) let start = date.startOf('week').format('YYYY-MM-DD HH:mm:ss') let end = date.endOf('week').format('YYYY-MM-DD HH:mm:ss') return [ start, end ] }   月 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 本月 function getCurrMonthDays () { let date = moment() let start = date.startOf('month').format('YYYY-MM-DD') let end = date.endOf('month').format('YYYY-MM-DD') return [ start, end ]; } // 上个月 function getLastMonthDays () { let date = moment().month(moment().month() - 1) let start = date.startOf('month').format('YYYY-MM-DD') let end = date.endOf('month').format('YYYY-MM-DD') return [ start, end ]; } // 下个月 function getNextMonthDays () { let date = moment().month(moment().month() + 1) let start = date.startOf('month').format('YYYY-MM-DD') let end = date.endOf('month').format('YYYY-MM-DD') return [ start, end ]; }   季度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 当前季度 function getCurrQuarter () { let date = moment() let start = date.startOf('quarter').format('YYYY-MM-DD') let end = date.endOf('quarter').format('YYYY-MM-DD') return [ start, end ]; } // 上个季度 function getLastQuarter () { let date = moment().quarter(moment().quarter() - 1) let start = date.startOf('quarter').format('YYYY-MM-DD') let end = date.endOf('quarter').format('YYYY-MM-DD') return [ start, end ]; } // 下个季度 function getLastQuarter () { let date = moment().quarter(moment().quarter() + 1) }   DRY -  Don't repeat yourself.\n 上面代码中可以看到有一个固定结构重复了好多次：\n1 2 3 4 5 6  function getX () { let date = x let start = date.startOf('时间单位类型').format('格式化') let end = date.endOf('时间单位类型').format('格式化') return [ start, end ]; }   所以我们可以专门封装一个函数，接收三个参数（时间，时间单位，格式化），返回开始和结束时间。\n1 2 3 4 5  function getDuringTime (date, type, format) { let start = date.startOf(type).format(format) let end = date.endOf(type).format(format) return [ start, end ]; }   有了此工具函数，将上面代码汇总如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  /** * @param {date} date [momentjs 时间对象] * @param {String} type [单位时间类型] * @param {String} format [时间格式] * type 可以接收的值： year, month, quarter, week, isoWeek, day, date, hour, minute, second */ function getDuringTime (date=moment(), type='days', format='YYYY-MM-DD HH:mm:ss') { let start = date.startOf(type).format(format) let end = date.endOf(type).format(format) return [ start, end ]; } // 获取当天开始结束时间 function getCurrDays () { let date = moment() return getDuringTime(date, 'days', 'YYYY-MM-DD') } // 获取昨天的开始结束时间 function getYesterday () { let date = moment().subtract('days',1) return getDuringTime(date, 'days', 'YYYY-MM-DD') } // 获取明天的开始结束时间 function getTomorrow () { let date = moment().add('days',1) return getDuringTime(date, 'days', 'YYYY-MM-DD') } // 获取某一周（本周，上周，下周）的开始结束时间，一周从周日开始到周六结束。 // 本周 function getCurrWeekDays () { let date = moment() return getDuringTime(date, 'week', 'YYYY-MM-DD') } // 上一周 function getLastWeekDays () { let date = moment().week(moment().week() - 1) return getDuringTime(date, 'week', 'YYYY-MM-DD') } // 下一周 function getNextWeekDays () { let date = moment().week(moment().week() + 1) return getDuringTime(date, 'week', 'YYYY-MM-DD') } // 本月 function getCurrMonthDays () { let date = moment() return getDuringTime(date, 'month', 'YYYY-MM-DD') } // 上个月 function getLastMonthDays () { let date = moment().month(moment().month() - 1) return getDuringTime(date, 'month', 'YYYY-MM-DD') } // 下个月 function getNextMonthDays () { let date = moment().month(moment().month() + 1) return getDuringTime(date, 'month', 'YYYY-MM-DD') } // 当前季度 function getCurrQuarter () { let date = moment() return getDuringTime(date, 'quarter', 'YYYY-MM-DD') } // 上个季度 function getLastQuarter () { let date = moment().quarter(moment().quarter() - 1) return getDuringTime(date, 'quarter', 'YYYY-MM-DD') } // 下个季度 function getLastQuarter () { let date = moment().quarter(moment().quarter() + 1) return getDuringTime(date, 'quarter', 'YYYY-MM-DD') }    本文完，感谢阅读。:stuck_out_tongue_winking_eye:\n","description":"","tags":["momentjs"],"title":"Get the Beginning and Ending in a Unit of Time via Momentjs","uri":"/2019-11-19/get-the-beginning-and-ending-in-a-unit-of-time-via-momentjs/"},{"categories":null,"content":" Ubuntu 基础设置，包含一些常用软件安装，配置文件修改等等。\n 这篇文章的意义在于，当你拿到一个新的 Ubuntu 系统之后，直接按照本文的步骤进行设置，就可以得到一个顺手的开发/部署环境。不再需要逐项搜索每个软件的安装步骤了。\n 设置国内软件镜像源 node git docker nginx oh-my-zsh alias vim  设置系统软件镜像源 配置系统源第一件事是修改镜像源，这样方便后续其他软件的安装。在国内可以选择阿里云的源。\n1 2 3 4 5 6  # 编辑源文件 sudo vim /etc/apt/sources.list # 在VIM编辑器内替换默认源为阿里云 :0,$ s/archive.ubuntu.com/mirrors.aliyun.com/ # 保存源文件并退出 :wq   包管理工具安装 先更新\n1  sudo apt update -y \u0026\u0026 sudo apt upgrade -y     Linux中apt与apt-get命令的区别与解释   linux命令系列 sudo apt-get update和upgrade的区别   安装常用软件\n通常会有一些是默认安装的，比如 git vim wget curl vim，如果没有，用下面方式安装即可。\n1  sudo apt install zsh nginx tree -y   oh-my-zsh 关于 zsh 和 oh-my-zsh 可以参考： 终极 Shell——ZSH 安装 脚本安装：\n1  wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh   或者手动安装:\n1 2  git clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc   安装完成之后退出当前会话重新打开一个终端窗口即可。\n插件 (1) autojump github 地址 autojump 下载并执行\n1 2  wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz ./install.sh   最后把以下代码加入.zshrc:\n1  [[ -s ~/.autojump/etc/profile.d/autojump.sh ]] \u0026\u0026 . ~/.autojump/etc/profile.d/autojump.sh   node(nvm) nvm github 地址： nvm-sh/nvm 方法一：脚本安装 执行脚本\n1 2 3  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash # 或者 wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash   最后，将下面内容分别添加到 ~/.bashrc, ~/.profile, 和 ~/.zshrc 文件中。\nexport NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] \u0026\u0026 printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 \\. \"$NVM_DIR/nvm.sh\" # This loads nvm 加载配置文件：\n1  source ~/.bashrc   方法二：git 安装 将代码克隆到用户目录下：\n1 2  cd ~/ git clone https://github.com/nvm-sh/nvm.git .nvm   切换到最新版本\n1 2  cd ~/.nvm git checkout v0.35.1   激活 nvm，在命令行执行：\n1  . nvm.sh   最后，将下面内容分别添加到 ~/.bashrc, ~/.profile, 和 ~/.zshrc 文件中。\nexport NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 \\. \"$NVM_DIR/nvm.sh\" # This loads nvm [ -s \"$NVM_DIR/bash_completion\" ] \u0026\u0026 \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion 完成之后，通过 nvm -v 查看版本来验证是否安装成功。\ndocker 安装 Docker 1  curl -fsSL https://get.docker.com -o get-docker.sh \u0026\u0026 sudo sh get-docker.sh   安装 Compose 1 2 3 4 5 6 7  sudo curl -L \"https://github.com/docker/compose/releases/download/1.22.0/docke-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose # 给Docker Compose 执行权限 sudo chmod +x /usr/local/bin/docker-compose #查看Docker和Docker Compose的版本 sudo docker version sudo docker-compose version   设置镜像源 执行下面命令进行设置\nps: 阿里云镜像源是个人注册阿里云账号之后分配的个人专属镜像源。\n1 2 3 4 5 6 7 8  sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://oojjt1xs.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker   vim 配置 有些系统默认没有安装\n配置文件路径：\n 全局配置文件：/etc/vim/vimrc 当前用户配置文件：~/.vimrc  将下面内容粘贴到配置文件中：\n\" 左单引号表示单行注释 \" 编码指定 UTF-8 set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 set termencoding=utf-8 set encoding=utf-8 set number \" 显示行号 set cursorline \" 突出显示当前行 set ruler \" 打开状态栏标尺 设置别名(alias) 将所有的别名放在单独一个文件 .bash_aliases 中，这样更加方便管理，ubuntu 也推荐这种做法。\n1 2 3  if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi   注意：等号两侧不能有空格!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 代替键盘上难以触及的 ~ 键 alias home=\"cd ~\" # 同样也可以为一些深层却很常用的目录设置别名 # 如：宝塔面包的 nginx 配置目录 alias ng=\"cd /www/server/panel/vhost/nginx\" # 回退多级目录 alias bk1=\"cd ..\" alias bk2=\"cd ../..\" alias bk3=\"cd ../../..\" alias bk4=\"cd ../../../..\" alias bk5=\"cd ../../../../..\" # ls 相关 alias cls='clear' alias ll='ls -l' alias la='ls -a' # git 相关 alias gs='git status' alias glog=\"git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cr eset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" # 解压 alias -s gz='tar -xzvf' alias -s tgz='tar -xzvf' alias -s zip='unzip' alias -s bz2='tar -xjvf' # other alias vi='vim' alias grep=\"grep --color=auto\" alias tree=\"tree -I '*svn|*node_module*'\"   Python3 系统升级到 ubuntu 20.04 之后，移除了 Python 2，只保留了 Python 3。\n因此默认不能执行 Python 命令，但可以执行 python3。\n因此我们可以在 /usr/bin 下创建一个软链接，指向 python3。\n1  sudo ln -s /usr/bin/python3 /usr/bin/python   注意：避免某些软件需要用的 python3，所以不建议把 python3 的软连接删除\n 本文完，感谢阅读。:stuck_out_tongue_winking_eye:\n","description":"","tags":["ubuntu"],"title":"Basic Setup for Ubuntu","uri":"/2019-11-17/basic-setup-for-ubuntu/"},{"categories":null,"content":"使用脚本快速安装 安装 Docker:\n1  curl -fsSL https://get.docker.com -o get-docker.sh \u0026\u0026 sudo sh get-docker.sh   安装 docker-compose\n1 2 3 4 5 6 7 8 9  sudo curl -L \"https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)\" \\ -o /usr/local/bin/docker-compose # 给Docker Compose 执行权限 sudo chmod +x /usr/local/bin/docker-compose # 查看Docker和Docker Compose的版本 sudo docker version sudo docker-compose version   设置阿里云镜像 1 2 3 4 5 6 7 8  sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://oojjt1xs.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker   阿里云镜像源需要个人注册阿里云账号之后才能使用，这里我已经注册过了。\n三个概念  Docker三个基本概念：Registry注册中心，Image镜像，Container容器\n  Registry包含多个Repo（仓库）和Tag(标签)，从Registry下载Image的方式是pull \u003c仓库名\u003e:\u003c标签名\u003e，如pull ubuntu:16.04\n  Image是一个静态概念，相当于面向对象中的类，类不能直接使用，需要实例化。\n  Container是一个动态概念，相当于面向对象中的实例化，启动镜像生成容器就是实例化类的过程。只有容器才能被用户使用。\n   查看命令    命令 描述     docker images 列出本地镜像   docker ps 列出容器    创建容器   创建一个新的容器，并进入交互模式的终端\n1  docker run -it centos:latest /bin/bash     后台运行容器，并设置端口映射\n1  docker run -d -p 3000:80 centos:latest     进入一个正在后台运行的容器\n1  docker attach [container-id]     退出容器   退出容器\n1  exit     退出容器并保持容器后台运行\nCtrl + p + q   从容器创建新的镜像   首先拿到容器 ID ，然后使用如下命令创建镜像：\n1  docker commit -a \"镜像作者名字\" -m \"提交时的说明文字\" [container-id] [image-name]:[tag]     WordPress 启动方式   创建容器\n1  docker run -it -p 3000:80 -p 4000:8888 my_wp:v1 /bin/bash     软件启动\n1 2 3 4 5 6 7 8 9  /etc/init.d/nginx start /etc/init.d/mysqld start /etc/init.d/memcached start /etc/init.d/php-fpm-72 start /etc/init.d/bt start     退出容器，并保持容器在后台运行\n1  Ctrl + p + q     相关文档   Docker命令大全 - 菜鸟教程   daocloud 镜像站   Docker — 从入门到实践(语雀)   ","description":"Docker 的快速安装、镜像源设置和基本使用","tags":["docker"],"title":"Basic Usage of Docker","uri":"/2019-11-16/basic-usage-of-docker/"},{"categories":null,"content":"安装 1 2  # ubuntu sudo apt install nginx -y   命令 nginx 命令    描述 命令 命令二     启动 sudo nginx sudo /usr/sbin/nginx   停止 sudo nginx -s stop sudo /usr/sbin/nginx -s stop   重启 sudo nginx -s restart sudo /usr/sbin/nginx -s restart   重载配置文件 sudo nginx -s reload sudo /usr/sbin/nginx -s reload    nginx 目录    描述 命令     nginx 安装目录 /usr/sbin/nginx   默认网站根目录 /usr/share/nginx/html   配置文件 /etc/nginx/nginx.conf     查找 nginx 安装目录的命令    描述 命令     查找 nginx 安装目录 which nginx   查找 nginx 配置文件 sudo find / -name nginx.conf   检测配置文件语法是否正确： sudo /usr/sbin/nginx -t    常见使用场景 (一) 静态网站 指定域名和对应的网站根目录位置，server_name 可以是域名、二级域名，也可以是 ip 地址。\nserver { listen 80; server_name demo.example.com; location / { root /www/demo/; index index.html index.htm; } } (二) 反向代理 场景：\n 解决跨域问题，利用 nginx 来访问其他域名下的接口 当 docker 服务的端口映射到宿主机上某个端口（如 8080）时，可以设置二级域名代理 8080 端口。  server { server_name docker.example.com; listen 80; location / { proxy_pass http://localhost:8000; proxy_set_header Host $host; proxy_set_header X-Forward-For $remote_addr; } } (三) 负载均衡 upstream backend { server backend1.example.com weight=5; server backend2.example.com:8080; server unix:/tmp/backend3; } server { location / { proxy_pass http://backend; } } 一些学习资源  Nginx中文文档 ","description":"Nginx 的安装和基本命令 | Basic Usage of Nginx","tags":["nginx"],"title":"Nginx 的安装和基本命令 | Basic Usage of Nginx","uri":"/2019-11-16/basic-usage-of-nginx/"},{"categories":null,"content":"初学 JavaScript 的时候，时常对于代码中 this 的值感到困惑，因为 JavaScript 中的 this 的值总是不确定的，每次都要将 this 的值打印出来才能放心。\n实际上 this 具体指向哪个对象是在函数运行时的环境动态绑定的，而非函数被声明时的环境。\n尽管如此，总还是有规律可循的，我们可以将 this 的场景大致分为下面 5 种：\n 作为普通函数调用 作为对象的方法调用 作为构造器调用 通过 call 和 apply 调用 箭头函数   在 ES6 标准新增的箭头函数中的 this 是由被声明的环境即上下文来确定的。\n 情况一：作为普通函数调用 这可能是我们学习过程中最先接触到的一种函数类型。\n1) 普通函数：\n当函数作为普通函数或者匿名函数调用时，this 总是指向全局对象，在浏览器中这个全局对象是 window，而在 nodejs 中全局对象是 global，这里讨论的是浏览器端，所有代码都可以在 chrome 开发者工具的 console 面板中执行。\n1 2 3 4 5 6 7 8 9  window.name = 'globalName' function printName1 () { console.log(this === window) console.log(this.name) } printName1() // true // \"globalName\"   ES5 规范提出了「严格模式」，启用方式是在整个脚本文件第一行或者函数内第一行添加一条语句 'use strict' 即可开启严格模式。\n如果启用「严格模式」，那么 this 就不再是指向全局对象，而是 undefined 。\n1 2 3 4 5 6  function printName2 () { \"use strict\" // 启用严格模式  console.log(this) // undefined } printName2()   2) 匿名函数：\n匿名函数自执行，这种形式封装公用库的时候最常见：\n1 2 3 4 5  window.name = 'globalName' (function () { console.log(this === window) // true  console.log(this.name) // \"globalName\" })()   和普通函数一样，匿名函数中的 this 也是指向全局对象。\n作为参数的匿名函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13  window.name = 'globalName' setTimeout(function () { console.log(this === window) // true  console.log(this.name) // \"globalName\" }, 100) [1, 2, 3].forEach(function (item) { console.log(item, this.name) // 1 \"globalName\"  // 2 \"globalName\"  // 3 \"globalName\" })   情况二：作为对象的方法调用 当函数作为对象当属性方法调用时，this 总指向这个对象。\n1 2 3 4 5 6 7 8 9  var obj = { name: 'obj', printName: function () { console.log(this === obj) // true  console.log(this.name) // \"obj\"  } } obj.printName()   但是如果一个对象的属性方法又赋值给了其他变量，那么 this 将发生变化，其指向只有在函数执行那一刻才能确定。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var obj = { name: 'obj', printName: function () { console.log(this === obj) // true  console.log(this.name) // \"obj\"  } } var myPrintName = obj.printName window.name = 'globalName' myPrintName() // false // \"globalName\"   当 myPrintName 执行时，就要按照普通函数来判断 this 指向了。\n再来一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var obj = { name: 'obj', printName: function () { console.log(this === obj) // true  console.log(this.name) // \"obj\"  } } var obj2 = { name: 'obj2', } obj2.printName = obj.printName obj2.printName() // false // \"obj2\"   当 obj2.printName 执行时，printName 是作为 obj2 的属性方法来调用的，因此 this 指向 obj2 这个对象。\n所以说，JavaScript 中的 this 指向无法在定义时判断，只有在其执行时才能判断。\n1 2 3 4  var printName () { console.log(this === window) console.log(this.name) }   情况三：作为构造器调用 在 JavaScript 中没有「类」的概念（直到 ES6 才有类的出现），而是把函数作为构造器，通过 new 操作符来生成实例。\n那么在构造函数中 this 就指向新生成的实例。\n1 2 3 4 5 6 7 8 9  var MyClass = function () { // 给实例添加 name 属性  this.name = 'myclass' this.printName = function () { return this.name } } var obj = new MyClass() obj.printName() // \"myclass\"   情况四：显式指定 this 前面的几种方法都是被动地根据代码执行时的环境来判断 this 具体指向哪里，那么有没有办法主动指定 this 指向呢。\n答案当然是有的，甚至它们的出场率还相当高。\n常见的显式指定 this 的方法主要是 call，apply 和 bind 来，在函数式编程中几乎离不开这三个方法。\n先定义如下变量：\n1 2 3 4 5 6 7 8  window.name = 'globalName' function printName () { console.log(this.name) } var obj1 = { name: 'obj1' } var obj2 = { name: 'obj2' } var obj3 = { name: 'obj3' }   默认情况 this 指向全局对象 window\n1  printName() // \"globalName\"   使用 call 来改变 this 指向：\n1  printName.call(obj1) // \"obj1\"   使用 apply 来改变 this 指向：\n1  printName.apply(obj2) // \"obj2\"   使用 bind 来改变 this 指向：\n1 2  var printName2 = printName.bind(obj3) printName2() // \"obj3\"   除此之外，还有一些函数也可以修改 this 指向，例如：forEach, map, filter, some, every 等。以 forEach 为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var obj = { name: 'zwc' } var arr = [ 1, 2 ] arr.forEach(function (item, index) { console.log(item, this) }) // 1 Window // 2 Window  arr.forEach(function (item, index) { console.log(item, this) }, obj) // 1 {name: \"zwc\"} // 2 {name: \"zwc\"}   forEach 第一个参数接收一个函数作为迭代器，用来处理数组中每一项元素，这个函数通常是一个匿名函数，函数内部的 this 指向全局对象。\nforEach 第二个参数可以接收一个对象，这个对象就是参数函数中的 this 指向。\n根据打印结果可以看到，在 forEach 的迭代器函数中的 this 已经指向了 obj 。\n情况五：ES6箭头函数 箭头函数简介 ES6 允许使用「箭头」（=\u003e）定义函数。\n1 2 3 4 5 6  var f = v =\u003e v // 等同于 var f = function (v) { return v }   除了形式更简洁之外，箭头函数没有自己的 this，而是从自己作用域链的上一层继承 this。\n 箭头函数总是从自己作用域链的上一层继承 this。\n 神马意思呢？我的理解就是箭头函数内部的 this 指向永远是箭头函数被定义时所在的作用域的 this，并且无法修改。\n无法绑定 this 使用 call 来调用箭头函数时，第一个参数会被忽略，也就是说无法修改 this 指向。apply 和 bind 也是同样现象。\n1 2 3 4 5 6 7  var printName = () =\u003e { console.log(this === window) // true } var obj = { name: 'obj' } printName.call(obj)   例子一 来看一个例子，在不使用箭头函数的情况下，我们知道构造器函数内部 this 指向对象实例，而匿名函数的 this 是指向全局对象的，因此想要通过定时器打印对象实例的 age 属性，只能用一个变量 self 保存 this 的引用（即闭包）\n1 2 3 4 5 6 7 8 9 10 11  function Person(){ // 构造器函数内部 this 指向对象实例  this.age = 0 var self = this setInterval(function () { // 匿名函数中 this 指向全局对象  console.log(self.age++) }, 1000) } var p = new Person()   使用箭头函数之后，因为箭头函数的 this 继承自其被定义时所在环境的 this，在本例中这个 this 就是实例对象：\n1 2 3 4 5 6 7 8 9 10  function Person(){ // 构造器函数内部 this 指向对象实例  this.age = 0 setInterval(() =\u003e { // 这里的 this 也指向构造函数的 this  console.log(this.age++) }, 1000) } var p = new Person()   例子二 再说一个更实用的例子：在 Vue.js 中使用箭头函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import axios from 'axios' export default { methods: { fetch () { axios.get('/userinfo') .then(resp =\u003e { this.sayHi() // this 指向 vue 实例  }) .catch(err =\u003e { this.sayHi() // this 指向 vue 实例  }) }, sayHi () { setTimeout(() =\u003e { // this 指向 vue 实例  }, 1000) } } }   使用箭头函数之后，再也无需缓存 vue 实例，像是 var vm = this 这种代码统统可以消灭掉，嗯，清爽！\n相关链接   严格模式 - MDN   箭头函数 - MDN   箭头函数 - ES6 入门   总结 在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值：\n 如果是该函数是一个普通函数或者匿名函数  在严格模式下的函数调用下，this 指向 undefined， 在非严格模式的函数调用中，this 指向全局对象，浏览器中全局对象是 window ，在 nodejs 中全局对象是 global   如果是该函数是一个构造函数，this 指针指向一个新的对象（实例） 如果是该函数是一个对象的方法，则它的this 指针指向这个对象 或者使用 call apply 等方法显式指定 this 的指向  在箭头函数中，则是根据箭头函数上下文决定其 this 指向，且无法修改 this 指向。\n 本文完，感谢阅读。:stuck_out_tongue_winking_eye:\n","description":"","tags":["JavaScript","this指向"],"title":"总结 JavaScript 中的 this 指向问题","uri":"/2019-09-29/this-in-javascript/"}]